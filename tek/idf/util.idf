
.class library
.name util					; as in tek_init_...
.copyright See copyright notice in teklib/COPYRIGHT

;.this struct TUtilBase *util	; first/implicit argument, default "TAPTR base"
.prefix TUtil				; name prefix heading non-inline functions
.iprefix T					; name prefix heading inline functions
.ibase TAPTR TUtilBase		; inline module base
.inline on					; generate inline calls

.defv void					; aliases for void
.defp TAPTR, TCMPFUNC, TSTRPTR ; pointer types
.defi TINT, TUINT, TBOOL	; 32bit integer types
.defs TUINT16				; 16bit integer types
.defd TDOUBLE				; double types
.deft TSIZE, TTAG, TINTPTR	; tag types

;------------------------------------------------------------------------------
;
;	tek/idf/util.idf - Util module interface
;	Written by Timm S. Mueller <tmueller at schulze-mueller.de>
;	See copyright notice in COPYRIGHT
;
;	FUNCTIONS::
;	- util:TBSwap16() - Swap bytes in a 16bit integer
;	- util:TBSwap32() - Swap bytes in a 32bit integer
;	- util:TDateToDMY() - Convert a date to day, month, year
;	- util:TDMYToYDay() - Convert a date to a year day
;	- util:TGetArgC() - Get application's argument count
;	- util:TGetArgs() - Return an application's arguments as a single string
;	- util:TGetArgV() - Get application's argument vector
;	- util:TGetRand() - Get pseudo random number
;	- util:TGetWeekDay() - Get day of week from day, month and year
;	- util:TGetWeekNumber() - Get week of year from day, month and year
;	- util:THeapSort() - Sort a field via reference array and comparison hook
;	- util:THToNL() - Convert 32bit integer from/to network byte order
;	- util:THToNS() - Convert 16bit integer from/to network byte order
;	- util:TIsBigEndian() - Test if host is big endian
;	- util:TIsLeapYear() - Check if a year is a leap year
;	- util:TIsValidDate() - Check if a date is valid
;	- util:TMYToDay() - Convert month, year to days since 1.1.1601
;	- util:TPackDate() - Pack a datebox structure to a TEKlib date
;	- util:TParseArgs() - Parse an argument string
;	- util:TParseArgV() - Parse argument vector
;	- util:TSeekList() - Seek in a list
;	- util:TSetRetVal() - Set application's return value
;	- util:TStrDup() - Allocate memory for and copy a string
;	- util:TStrNDup() - Allocate memory for and copy a string, length-limited
;	- util:TUnpackDate() - Unpack a TEKlib date to a datebox structure
;	- util:TYDayToDM() - Convert year day to day and month
;
;------------------------------------------------------------------------------

.offset 9
;------------------------------------------------------------------------------
;
;	TGetArgC():
;			argc = TGetArgC()
;			TINT
;
;	FUNCTION::
;	Return an application's argument count.
;
;	RESULTS::
;		- {{argc}} - Number of arguments passd to the application
;
;	The result will be {{0}} if an argument vector is unsupported
;	by the application startup.
;
;	SEE ALSO::
;	util:TGetArgV(), util:TSetRetVal()
;
;------------------------------------------------------------------------------
TINT GetArgC()

;------------------------------------------------------------------------------
;
;	TGetArgV():
;			argv = TGetArgV()
;			TSTRPTR*
;
;	FUNCTION::
;	Return an application's array of arguments.
;
;	RESULTS::
;		- {{argv}} - Pointer to a {{TNULL}}-terminated array of string
;		pointers
;
;	The argument vector contains the arguments supplied to the application,
;	or {{TNULL}} if an argument vector is unsupported by the application
;	startup.
;
;	NOTES::
;	If an {{argv}} vector is available, then it will always be terminated
;	with an additional array element containing {{TNULL}}.
;
;	SEE ALSO::
;	util:TGetArgC(), util:TSetRetVal()
;
;------------------------------------------------------------------------------
TSTRPTR *GetArgV()

;------------------------------------------------------------------------------
;
;	TSetRetVal():
;			success = TSetRetVal(value)
;			TBOOL                TINT
;
;	FUNCTION::
;	Set an application-wide return value. If supported by the
;	application's entry point, the value will be returned to the
;	hosting environment.
;
;	RESULTS::
;		- {{success}} - {{TTRUE}} if setting the return value succeeded.
;
;	INPUTS::
;		- {{value}} - Return value to set in the application
;
;	SEE ALSO::
;	util:TGetArgC(), util:TGetArgV()
;
;------------------------------------------------------------------------------
TBOOL SetRetVal(TINT retval)

;------------------------------------------------------------------------------
;
;	THeapSort():
;			success = THeapSort(refarray, length, hook)
;			TBOOL               TTAG*     TUINT   struct THook*
;
;	FUNCTION::
;	Using the Heapsort algorithm, sort data of the given length, via
;	a reference array and comparison hook. This layout allows you
;	to sort any kind of data structure, including arrays of any type,
;	and even lists. The reference array will usually contain indices or
;	pointers.
;
;	RESULTS::
;		- {{success}} - Boolean
;
;	Possible reasons for failure are: No comparison function or reference
;	array given or less than two entries to sort.
;
;	INPUTS::
;		- {{refarray}} - Array of references, i.e. indices or pointers
;		- {{length}} - Number of entries to be sorted
;		- {{hook}} - Comparison hook
;
;	The comparison hook function must return a value less than zero
;	indicating "ref1 less than ref2", a value greater zero indicating
;	"ref1 greater than ref2", and zero for "ref1 equal to ref2". It
;	expects a pointer to the following data structure as its object:
;
;			struct CmpData { TTAG ref1; TTAG ref2; };
;
;	NOTES::
;	The Heapsort algorithm is slower than Quicksort, but it has no
;	stack impact, and its performance is insensitive to the initial
;	array order.
;
;------------------------------------------------------------------------------
TBOOL HeapSort(TAPTR refarray, TSIZE len, struct THook *cmphook)

;------------------------------------------------------------------------------
;
;	TSeekList():
;			newnode = TSeekNode(node,         steps)
;			struct TNode*       struct TNode* TINTPTR
;
;	FUNCTION::
;	Seek in a doubly linked list by a given number of steps either
;	forward (steps > 0) or backward (steps < 0), and return the
;	node reached, or {{TNULL}} if seeked past end or before start of
;	the list. If steps is zero, node is returned.
;
;	RESULTS::
;		- {{newnode}} - Node reached, or {{TNULL}}
;
;	INPUTS::
;		- {{node}} - Starting node
;		- {{steps}} - Number of steps to seek
;
;------------------------------------------------------------------------------
struct TNode *SeekList(struct TNode *node, TINTPTR steps)

;------------------------------------------------------------------------------
;
;	TIsBigEndian():
;			isbig = TIsBigEndian()
;			TBOOL
;
;	FUNCTION::
;	Determine the host's endianness. If the host is a big endian
;	architecture, a 32bit register containing {{0x11223344}} stored in
;	memory would yield the byte sequence {{0x11}}, {{0x22}}, {{0x33}},
;	{{0x44}}. On such an architecture, this function returns {{TTRUE}}. On
;	a little endian architecture, the byte sequence would be {{0x44}},
;	{{0x33}}, {{0x22}}, {{0x11}}, and this function returned {{TFALSE}}.
;
;	RESULTS::
;		- {{isbig}} - Boolean. {{TTRUE}} if the host is big endian.
;
;	SEE ALSO::
;	util:THToNL(), util:THToNS(), util:TBSwap16(), util:TBSwap32()
;
;------------------------------------------------------------------------------
TBOOL IsBigEndian()

;------------------------------------------------------------------------------
;
;	TBSwap16():
;			TBSwap16(valp)
;			         TUINT16*
;
;	FUNCTION::
;		Reverse the order of the two bytes in memory to which {{valp}}
;		points.
;
;	INPUTS::
;		- {{valp}} - Pointer to a 16bit integer to swap
;
;	SEE ALSO::
;	util:THToNL(), util:TBSwap32(), util:TIsBigEndian()
;
;------------------------------------------------------------------------------
void BSwap16(TUINT16 *valp)

;------------------------------------------------------------------------------
;
;	TBSwap32():
;			TBSwap32(valp)
;			         TUINT*
;
;	FUNCTION::
;		Reverse the order of the four bytes in memory to which {{valp}}
;		points.
;
;	INPUTS::
;		- {{valp}} - Pointer to a 32bit integer to swap
;
;	SEE ALSO::
;	util:THToNL(), util:TBSwap16(), util:TIsBigEndian()
;
;------------------------------------------------------------------------------
void BSwap32(TUINT *valp)

;------------------------------------------------------------------------------
;
;	TStrDup():
;			dup = TStrDup(memmanager,         string)
;			TSTRPTR       struct TMemManager* TSTRPTR
;
;	FUNCTION::
;	Allocate memory for, copy, and return a pointer to a duplicate of
;	a string. If string is {{TNULL}}, a string will be allocated containing
;	only a string's trailing zero-byte.
;
;	RESULTS::
;		- {{dup}} - A copy of the string, or {{TNULL}} if out of memory.
;
;	INPUTS::
;		- {{memmanager}} - Memory manager to allocate from, or {{TNULL}}
;		- {{string}} - String to be duplicated
;
;	NOTES::
;		The resulting string must be freed using exec:TFree().
;
;	SEE ALSO::
;	util:TStrNDup()
;
;------------------------------------------------------------------------------
TSTRPTR StrDup(struct TMemManager *mm, TSTRPTR str)

;------------------------------------------------------------------------------
;
;	TStrNDup():
;			dup = TStrNDup(memmanager,         string, maxlen)
;			TSTRPTR        struct TMemManager* TSTRPTR TSIZE
;
;	FUNCTION::
;	Allocate memory for, copy, and return a pointer to a duplicate of
;	a string. If string is {{TNULL}}, a string will be allocated containing
;	only a string's trailing zero-byte. The duplicate will be limited to
;	a maximum of maxlen characters.
;
;	RESULTS::
;		- {{dup}} - A copy of the string, or {{TNULL}} if out of memory.
;
;	INPUTS::
;		- {{memmanager}} - Memory manager to allocate from, or {{TNULL}}
;		- {{string}} - String to be duplicated
;		- {{maxlen}} - Maximum number of bytes to duplicate
;
;	NOTES::
;		The resulting string must be freed using exec:TFree().
;
;	SEE ALSO::
;	util:TStrDup()
;
;------------------------------------------------------------------------------
TSTRPTR StrNDup(struct TMemManager *mm, TSTRPTR str, TSIZE len)

;------------------------------------------------------------------------------
;
;	TGetRand():
;			num = TGetRand(seed)
;			TUINT          TUINT
;
;	FUNCTION::
;	From a seeding previous random number, generate a pseudo random
;	number in the range from 0 to 2147483647 (hexadecimal
;	{{0x7fffffff}}).
;
;	RESULTS::
;		- {{num}} - Pseudo random number
;
;------------------------------------------------------------------------------
TUINT GetRand(TUINT seed)

;------------------------------------------------------------------------------
;
;	TParseArgV():
;			handle = TParseArgV(template, argv,    args)
;			struct THandle*     TSTRPTR   TSTRPTR* TTAG*
;
;	FUNCTION::
;	Parse an array of string pointers into an arguments array,
;	according to a format template.
;
;	The array of string pointers is here referred to as 'argv', because
;	a typical use of this function is to parse an application's
;	commandline arguments. Note, however, that it can be applied to any
;	other {{TNULL}}-terminated array of string pointers as well.
;
;	The template string specifies the expected format. Options in the
;	template are separated by commas. Each argument consists of a
;	name, an optional alias, and an optional set of qualifiers. Example:
;
;			-s=SOURCE/A/M,-d=DEST/A/K
;
;	This format would require one or more source arguments and a single
;	destination argument. Neither can be omitted. The SOURCE keyword (or
;	its alias -s) does not need to appear in the command line. The DEST
;	keyword (or its alias -d) must appear in the commandline to be valid.
;	This is how the template would be interpreted:
;
;	SOURCE one two three DEST foo  || Valid
;	DEST foo -s one                || Valid
;	DEST foo                       || Rejected - source missing
;	one two three foo              || Rejected - keyword missing
;	one two dest foo               || Valid - keywords are not case-sensitive
;	one two three -d foo four      || Valid - "four" would be added to SOURCE
;
;	An option without qualifiers represents a string argument. If
;	present, a pointer to the string will be placed into the
;	respective entry in the args array. Qualifiers are:
;
;	{{/S}} - Switch. This is considered a boolean variable. When this
;	option is present, the value TTRUE will be written into the
;	respective entry in the args array.
;
;	{{/N}} - This argument is considered an integer in decimal notation.
;	When present, a pointer to a 32bit signed integer will be placed
;	into the respective entry in the args array. A pointer to the
;	number is inserted (not the number itself) so that the caller can
;	determine whether the argument was specified.
;
;	{{/K}} - Keyword. The option will not be accepted unless the keyword
;	appears in the argv vector.
;
;	{{/A}} - Required. This argument cannot be omitted. If not present,
;	an error is returned.
;
;	{{/M}} - Multiple strings. Any number of strings will be accepted for
;	this option. Not more than one /M modifier should appear in a
;	template. Any arguments that cannot be assigned to other options
;	will be added to this option. The respective entry in the args
;	array will be a pointer to a TNULL-terminated array of string
;	pointers.
;
;	If parsing is successful, this function returns a handle. When you
;	are finished processing the arguments, this handle must be passed
;	to teklib:TDestroy() to free all associated memory.
;
;	INPUTS::
;		- {{template}} - Format string
;		- {{argv}} - Array of string pointers to be parsed
;		- {{args}} - Pointer to an array of tags to be filled with arguments
;
;	RESULTS::
;		- {{handle}} - argument handle
;
;	The argument handle will be TNULL if parsing failed. When the application
;	has finished processing the arguments, the handle must be passed to
;	teklib:TDestroy() for freeing all associated memory.
;
;	EXAMPLE::
;			/* Template string */
;			TSTRPTR template = "-f=FROM/A,-c=CONTEXT/K,-r=RECURSE/S,-h=?/S";
;
;			/* Initialize args array to defaults */
;			TTAG args[4] = {TNULL, (TTAG) "linux_gcc", TFALSE, TFALSE};
;
;			/* Get argv vector */
;			TSTRPTR *argv = TGetArgV();
;
;			/* Pass argv + 1 so the program name argv[0] is excluded */
;			struct THandle *argh = TParseArgV(template, argv + 1, args);
;
;			if (argh && !args[3])
;			{
;			    /* Use the arguments here. Do not destroy the handle yet! */
;			}
;			else
;			{
;			    /* Either parsing failed or the "help" option was given */
;			    printusage();
;			}
;
;			/* Clean up */
;			TDestroy(argh);
;
;------------------------------------------------------------------------------
struct THandle *ParseArgV(TSTRPTR tmpl, TSTRPTR *argv, TTAG *argarray)

;------------------------------------------------------------------------------
;
;	THToNL():
;			val = THToNL(val)
;			TUINT         TUINT
;
;	FUNCTION::
;	If the software is running on a little-endian architecture, this function
;	will byte-swap the value. On a big-endian architecture, it will be
;	returned unmodified. This will convert the specified value from/to
;	network byte order on any architecture.
;
;	RESULTS::
;		- {{val}} - 32bit integer, byte-swapped if running on little-endian
;
;	INPUTS::
;		- {{val}} - 32bit integer
;
;	SEE ALSO::
;	util:THToNS(), util:TIsBigEndian(), util:TBSwap32()
;
;------------------------------------------------------------------------------
TUINT HToNL(TUINT val)

;------------------------------------------------------------------------------
;
;	THToNS():
;			val = THToNS(val)
;			TUINT16      TUINT16
;
;	FUNCTION::
;	If the software is running on a little-endian architecture, this function
;	will byte-swap the value. On a big-endian architecture, it will be
;	returned unmodified. This will convert the specified value from/to
;	network byte order on any architecture.
;
;	RESULTS::
;		- {{val}} - 16bit integer, byte-swapped if running on little-endian
;
;	INPUTS::
;		- {{val}} - 16bit integer
;
;	SEE ALSO::
;	util:THToNL(), util:TIsBigEndian(), util:TBSwap16()
;
;------------------------------------------------------------------------------
TUINT16 HToNS(TUINT16 val)

;------------------------------------------------------------------------------
;
;
;------------------------------------------------------------------------------
TINT GetModules(TSTRPTR prefix, struct TList *list, TTAGITEM *tags)

;------------------------------------------------------------------------------
;
;	TParseArgs():
;			handle = TParseArgs(template, argstring, argarray)
;			struct THandle*     TSTRPTR   TSTRPTR    TTAG*
;
;	FUNCTION::
;	Parse an argument string into an arguments array, according to a
;	format template.
;
;	The template string specifies the expected format. Options in the
;	template are separated by commas. Each argument consists of a
;	name, an optional alias, and an optional set of qualifiers.
;
;	If parsing is successful, then this function returns a handle. When
;	you are finished processing the arguments, this handle must be
;	passed to teklib:TDestroy() for freeing all associated memory.
;
;	See util:TParseArgV() for a detailed description of the expected format.
;
;	RESULTS::
;		- {{handle}} - Argument handle, or {{TNULL}} if parsing failed
;
;	INPUTS::
;		- {{template}} - Format string
;		- {{argv}} - Array of string pointers to be parsed
;		- {{args}} - Pointer to an array of tags to be filled
;
;	SEE ALSO::
;	util:TGetArgs(), util:TParseArgV()
;
;------------------------------------------------------------------------------
struct THandle *ParseArgs(TSTRPTR template, TSTRPTR argstring, TTAG *argarray)

;------------------------------------------------------------------------------
;
;	TGetArgs():
;			args = TGetArgs()
;			TSTRPTR
;
;	FUNCTION::
;	Return an application's argument vector ({{argv}}) in a single string,
;	with the individual items being seperated with spaces.
;
;	RESULTS::
;		- {{args}} - application arguments
;
;	SEE ALSO::
;	util:TGetArgV()
;
;------------------------------------------------------------------------------
TSTRPTR GetArgs()

;------------------------------------------------------------------------------
;
;
;------------------------------------------------------------------------------
struct THash *CreateHash(TTAGITEM *tags)

;------------------------------------------------------------------------------
;
;
;------------------------------------------------------------------------------
TBOOL PutHash(struct THash *, TTAG key, TTAG value)

;------------------------------------------------------------------------------
;
;
;------------------------------------------------------------------------------
TBOOL GetHash(struct THash *, TTAG key, TTAG *valuep)

;------------------------------------------------------------------------------
;
;
;------------------------------------------------------------------------------
TBOOL RemHash(struct THash *, TTAG key)

;------------------------------------------------------------------------------
;
;
;------------------------------------------------------------------------------
TUINT HashToList(struct THash *, struct TList *list)

;------------------------------------------------------------------------------
;
;
;------------------------------------------------------------------------------
void HashUnList(struct THash *)

;------------------------------------------------------------------------------
;
;	TIsLeapYear():
;			isleapyear = TIsLeapYear(year)
;			TBOOL                    TUINT
;
;	FUNCTION::
;	Check if year is a leap year.
;
;	RESULTS::
;		- {{isleapyear}} - TTRUE if leap year, TFALSE otherweise
;
;	INPUTS::
;		- {{year}} - Year to check
;
;	SEE ALSO::
;	util:TIsValidDate()
;
;------------------------------------------------------------------------------
TBOOL IsLeapYear(TUINT y)

;------------------------------------------------------------------------------
;
;	TIsValidDate():
;			valid = TIsValidDate(day,  month, year)
;			TBOOL                TUINT TUINT  TUINT
;
;	FUNCTION::
;	Check if the given combination from day, month, year is a
;	valid date, e.g. 29, 2, 2003 would be an invalid date, and
;	this function would return {{TFALSE}}.
;
;	RESULTS::
;		- {{valid}} - Boolean
;
;	INPUTS::
;		- {{day, month, year}} - Date
;
;	SEE ALSO::
;	util:TIsLeapYear()
;
;------------------------------------------------------------------------------
TBOOL IsValidDate(TUINT d, TUINT m, TUINT y)

;------------------------------------------------------------------------------
;
;	TYDayToDM():
;			success = TYDayToDM(yearday, year, pday,  pmonth)
;			TBOOL               TUINT    TUINT TUINT* TUINT*
;
;	FUNCTION::
;	Convert a year and yearday to a month's day and month of the
;	given year.
;
;	INPUTS::
;		- {{yearday}} - Daynumber in the respective year
;		- {{year}} - The year
;		- {{pday}} - Pointer to an integer receiving the day (may be {{TNULL}})
;		- {{pmonth}} - Pointer to an integer receiving the month (may be
;		{{TNULL}})
;
;	SEE ALSO::
;	util:TDMYToYDay(), util:TMYToDay(), util:TPackDate(), util:TUnpackDate(),
;	util:TDateToDMY()
;
;------------------------------------------------------------------------------
TBOOL YDayToDM(TUINT yday, TUINT y, TUINT *pd, TUINT *pm)

;------------------------------------------------------------------------------
;
;	TDMYToYDay():
;			yday = TDMYToYDay(day,  month, year)
;			TUINT             TUINT TUINT  TUINT
;
;	FUNCTION::
;	Convert a date in the format day, month, year to yearday
;	of the given year.
;
;	RESULTS::
;		- {{yday}} - Day of the year
;
;	INPUTS::
;		- {{day, month, year}} - Date
;
;	SEE ALSO::
;	util:TYDayToDM(), util:TMYToDay(), util:TPackDate(), util:TUnpackDate(),
;	util:TDateToDMY()
;
;------------------------------------------------------------------------------
TUINT DMYToYDay(TUINT d, TUINT m, TUINT y)

;------------------------------------------------------------------------------
;
;	TMYToDay():
;			day = TMYToDay(month, year)
;			TUINT          TUINT  TUINT
;
;	FUNCTION::
;	From the given month and year, calculate the number of days since
;	1-Jan-1601.
;
;	RESULTS::
;		- {{day}} - Day number since 1.1.1601
;
;	INPUTS::
;		- {{month}} - Month to convert
;		- {{year}} - Year to convert
;
;	SEE ALSO::
;	util:TYDayToDM(), util:DMYToYDay(), util:TPackDate(), util:TUnpackDate(),
;	util:TDateToDMY()
;
;------------------------------------------------------------------------------
TUINT MYToDay(TUINT m, TUINT y)

;------------------------------------------------------------------------------
;
;	TDateToDMY():
;			TDateToDMY(date,  pday,  pmonth, pyear, ptime)
;			           TDATE* TUINT* TUINT*  TUINT* TTIME*
;
;	FUNCTION::
;	This function converts a date to a day, month, year, and
;	the remaining fraction of the day into a time structure.
;
;	INPUTS::
;		- {{date}} - TEKlib Date
;		- {{pday}} - Pointer to an integer for day (may be {{TNULL}})
;		- {{pmonth}} - Pointer to an integer for month (may be {{TNULL}})
;		- {{pyear}} - Pointer to an integer for year (may be {{TNULL}})
;		- {{ptime}} - Pointer to a TEKlib time (may be {{TNULL}})
;
;	SEE ALSO::
;	util:TYDayToDM(), util:TDMYToYDay(), util:TMYToDay(), util:TPackDate(),
;	util:TUnpackDate()
;
;------------------------------------------------------------------------------
void DateToDMY(TDATE *td, TUINT *pD, TUINT *pM, TUINT *pY, TTIME *pT)

;------------------------------------------------------------------------------
;
;	TGetWeekDay():
;			wday = TGetWeekDay(day,  month, year)
;			TUINT              TUINT TUINT  TUINT
;
;	FUNCTION::
;	This function gets the week's day number (0, sunday - 6, saturday)
;	from a date given by day, month, year.
;
;	RESULTS::
;		- {{wday}} - Day of week
;
;	INPUTS::
;		- {{day}} - Day
;		- {{month}} - Month
;		- {{year}} - Year
;
;	SEE ALSO::
;	util:TGetWeekNumber()
;
;------------------------------------------------------------------------------
TUINT GetWeekDay(TUINT d, TUINT m, TUINT y)

;------------------------------------------------------------------------------
;
;	TGetWeekNumber():
;			wnumber = TGetWeekDay(day,  month, year)
;			TUINT                 TUINT TUINT  TUINT
;
;	FUNCTION::
;	This function gets the year's week number from a date given by
;	day, month, year.
;
;	RESULTS::
;		- {{wnumber}} - Week of year
;
;	INPUTS::
;		- {{day}} - Day
;		- {{month}} - Month
;		- {{year}} - Year
;
;	SEE ALSO::
;	util:TGetWeekDay()
;
;------------------------------------------------------------------------------
TUINT GetWeekNumber(TUINT d, TUINT m, TUINT y)

;------------------------------------------------------------------------------
;
;	TPackDate():
;			success = TPackDate(datebox,         tdate)
;			TBOOL               struct TDateBox* TDATE*
;
;	FUNCTION::
;	Convert a datebox structure to a date. All fields with a
;	corresponding bit in {{datebox->tdb_Fields}} will be possibly
;	taken into account. Fields required are {{TDB_YEAR}} and either
;	{{TDB_MONTH}}, {{TDB_DAY}} or {{TDTB_YDAY}}. More fields like
;	{{TDB_HOUR}}, {{TDB_MINUTE}} etc. will be incorporated to the
;	resulting date as well, if they are present. If not enough
;	relevant fields are provided then this function returns {{TFALSE}}.
;
;	See util:TUnpackDate() for a description of the flags in
;	{{datebox->tdb_Fields}}.
;
;	RESULTS::
;		- {{success}} - {{TTRUE}} if conversion succeeded
;
;	INPUTS::
;		- {{datebox}} - Pointer to a source datebox structure
;		- {{tdate}} - Pointer to a destination {{TDATE}}
;
;	SEE ALSO::
;	util:TUnpackDate()
;
;------------------------------------------------------------------------------
TBOOL PackDate(struct TDateBox *db, TDATE *td)

;------------------------------------------------------------------------------
;
;	TUnpackDate():
;			TUnpackDate(date,  datebox,         fields)
;			            TDATE* struct TDateBox* TUINT16
;
;	FUNCTION::
;	Convert a date to a datebox structure. At least the fields
;	marked in the fields argument will be inserted to the
;	resulting datebox structure.
;
;	Specific combinations of date fields may be sufficient for
;	a given purpose, like {{TDB_DAY|TDB_MONTH|TDB_YEAR}} or
;	{{TDB_YDAY|TDB_YEAR|TDB_SEC}}. If you want to receive all
;	fields, pass {{TDB_ALL}} in the fields argument. The fields
;	actually being inserted by this function (which can be more
;	than requested) will be flagged as correponding bits in
;	{{datebox->tdb_Fields}}.
;
;	INPUTS::
;		- {{date}} - pointer to a source date
;		- {{datebox}} - pointer to a TDateBox structure to be filled in
;		- {{fields}} - Fields to be inserted into the datebox structure.
;		Valid flag fields:
;
;		'''Flag''' || '''Description''' || '''corresponds to'''
;		TDB_YEAR   || year				|| datebox->tdb_Year
;		TDB_YDAY   || day of year		|| datebox->tdb_YDay
;		TDB_MONTH  || month of year		|| datebox->tdb_Month
;		TDB_WEEK   || week of year		|| datebox->tdb_Week
;		TDB_WDAY   || day of week		|| datebox->tdb_WDay
;		TDB_DAY    || day of month		|| datebox->tdb_Day
;		TDB_HOUR   || hour of day		|| datebox->tdb_Hour
;		TDB_MINUTE || minute of hour	|| datebox->tdb_Minute
;		TDB_SEC    || second of minute	|| datebox->tdb_Sec
;		TDB_USEC   || 1/1000000th sec	|| datebox->tdb_USec
;		TDB_ALL    || all of the above  || all of the above
;
;	SEE ALSO::
;	util:TPackDate()
;
;------------------------------------------------------------------------------
void UnpackDate(TDATE *td, struct TDateBox *db, TUINT16 rf)

.end
