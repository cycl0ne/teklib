<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<title>TEKlib reference manual</title>
		<link rel="stylesheet" href="manual.css" />
	</head>
	<body>
		<h1>
			TEKlib reference manual
		</h1>
		<h2>
			Modules and libraries
		</h2>
		<blockquote>
			<ul>
				<li>
					astro
				</li>
				<li>
					display
				</li>
				<li>
					<a href="#exec">exec</a> 
				</li>
				<li>
					hal
				</li>
				<li>
					io
				</li>
				<li>
					lua5
				</li>
				<li>
					ps2
				</li>
				<li>
					<a href="#string">string</a> 
				</li>
				<li>
					<a href="#teklib">teklib</a> 
				</li>
				<li>
					<a href="#util">util</a> 
				</li>
				<li>
					visual
				</li>
			</ul>
		</blockquote>
		<hr />
		<div class="node"><h2><a name="teklib" id="teklib">teklib </a></h2>
			<div class="definition"><dfn>OVERVIEW</dfn>
				<p>
					The majority of TEKlib's functionality is located in shared modules.
					The link libraries provide only functions that operate on elementary
					data structures (such as <a href="#lists">lists</a>, hooks and <a href="#taglists">taglists</a>), and
					they allow the setup of applications and modules.
				</p>
			</div>
			<div class="definition"><dfn>LIBRARIES</dfn>
				<ul>
					<li>
						<code>tek</code> -
						Common functions for elementary datatypes and module setup,
						usually linked to modules
					</li>
					<li>
						<code>tekc</code> -
						Additionally provides <a href="#teklib:TEKCreate"><code>teklib:TEKCreate()</code></a>. This library is linked
						to applications that wish to embed TEKlib, but do not use
						<a href="#teklib:TEKMain"><code>teklib:TEKMain()</code></a> as their application entrypoint.
					</li>
					<li>
						<code>tekcmain</code> -
						Additionally resolves a platform-specific <code>main()</code> and calls
						<a href="#teklib:TEKMain"><code>teklib:TEKMain()</code></a>. This is the typical C/C++ language startup of a
						freestanding TEKlib application.
					</li>
					<li>
						<code>tekmain</code> -
						This library is based on <code>tekc</code> and additionally defines an
						entrypoint for applications on platforms on which TEKlib constitutes
						the operating system. This is the case on the Playstation 2
						architecture, for example.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>FUNCTIONS</dfn>
				<ul>
					<li style="list-style-type: none">
						<a href="#teklib:TAddDate"><code>teklib:TAddDate()</code></a> - Add number of days and a time to a date
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TAddHead"><code>teklib:TAddHead()</code></a> - Add a node at the head of a list
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TAddTail"><code>teklib:TAddTail()</code></a> - Add a node at the tail of a list
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TAddTime"><code>teklib:TAddTime()</code></a> - Add a time to another
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TCallHookPkt"><code>teklib:TCallHookPkt()</code></a> - Invoke a hook
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TCmpTime"><code>teklib:TCmpTime()</code></a> - Compare times
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TCreateTime"><code>teklib:TCreateTime()</code></a> - Create a time from days, seconds, micros
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a> - Destroy a handle
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TDestroyList"><code>teklib:TDestroyList()</code></a> - Unlink all nodes in a list and destroy them
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TDiffDate"><code>teklib:TDiffDate()</code></a> - Calculate days and time difference between dates
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TEKCreate"><code>teklib:TEKCreate()</code></a> - Create an initial TEKlib task/thread context
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TEKMain"><code>teklib:TEKMain()</code></a> - Entrypoint for a freestanding application
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TExtractTime"><code>teklib:TExtractTime()</code></a> - Extract days, seconds, micros from a time
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TFindHandle"><code>teklib:TFindHandle()</code></a> - Find a named handle in a list
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TForEachTag"><code>teklib:TForEachTag()</code></a> - Traverse all key/value pairs in a tag list
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TFreeInstance"><code>teklib:TFreeInstance()</code></a> - Free a module instance
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TGetTag"><code>teklib:TGetTag()</code></a> - Get a value from a list of tagitems
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TInitHook"><code>teklib:TInitHook()</code></a> - Initialize a hook with a function and data
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TInitInterface"><code>teklib:TInitInterface()</code></a> - Initialize an interface structure
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TInitList"><code>teklib:TInitList()</code></a> - Initialize a list structure
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TInitVectors"><code>teklib:TInitVectors()</code></a> - Initialize a module function table
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TInsert"><code>teklib:TInsert()</code></a> - Insert a node into a list
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TNewInstance"><code>teklib:TNewInstance()</code></a> - Create a module instance copy
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TNodeUp"><code>teklib:TNodeUp()</code></a> - Move a node towards the head of its list
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TRemHead"><code>teklib:TRemHead()</code></a> - Remove a node from the head of a list
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TRemove"><code>teklib:TRemove()</code></a> - Remove a node from whatever list it is linked to
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TRemTail"><code>teklib:TRemTail()</code></a> - Remove a node from the tail of a list
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TSubDate"><code>teklib:TSubDate()</code></a> - Subtract a number of days and a time from a date
					</li>
					<li style="list-style-type: none">
						<a href="#teklib:TSubTime"><code>teklib:TSubTime()</code></a> - Subtract a time from another
					</li>
				</ul>
				<hr />
			</div>
		</div>
		<div class="node"><h2><a name="taglists" id="taglists">Taglists</a></h2>
			<p>
				One of the most versatile data structures in TEKlib are arrays of
				key/value pairs. These pairs are called <em>tags</em>, hence the term
				<em>tagitem</em> for the resulting data structure, and <em>taglist</em> for an
				array composed of tagitems. Example:
			</p>
<pre>
struct TTagItem my_taglist&#091;5&#093; =
{
    MY_Points, vertices,
    MY_NumPoints, (TTAG) 3,
    MY_Color, (TTAG) 0xff0000,
    MY_Name, &quot;Red triangle&quot;,
    TTAG_DONE
};
</pre>
			<p>
				The <code>TTAG</code> type has the guaranteed ability to carry pointers on all
				architectures. This allows, in essence, to transport any kind of data
				in tagitems. The <code>tti_Tag</code> field can contain user codes or control
				codes. User codes are identified by their combination with
				<code>TTAG_USER</code>, for example
			</p>
<pre>
#define MY_Points    (TTAG_USER + 0x10001)
#define MY_NumPoints (TTAG_USER + 0x10002)
#define MY_Color     (TTAG_USER + 0x10003)
#define MY_Name      (TTAG_USER + 0x10004)
</pre>
			<p>
				A tag not containing <code>TTAG_USER</code> is considered a control tag, which
				determines how a single item is to be interpreted, or how an array
				of tagitems should be traversed. The meanings of control tags are:
			</p>
			<blockquote>
				<ul>
					<li style="list-style-type: none">
						<code>TTAG_DONE</code> 
						<blockquote>
							<p>
								End of the taglist; traversal stops at this item.
							</p>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>TTAG_IGNORE</code> 
						<blockquote>
							<p>
								<code>tti_Value</code> of this item is to be ignored.
							</p>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>TTAG_SKIP</code> 
						<blockquote>
							<p>
								The current item plus the number of items in
								<code>tti_Value</code> is to be ignored.
							</p>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>TTAG_MORE</code> 
						<blockquote>
							<p>
								<code>tti_Value</code> points to another taglist, at which
								traversal is to be continued. The control does not
								return to the current item.
							</p>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>TTAG_GOSUB</code> 
						<blockquote>
							<p>
								<code>tti_Value</code> points to another taglist, which is
								traversed recursively. After traversal, control
								returns to the current item.
							</p>
						</blockquote>
					</li>
				</ul>
			</blockquote>
			<p>
				Once a function is designed to accept a taglist argument, it becomes
				more flexible for future API changes. By assigning a default
				value to each tag argument, any number of new taglist arguments can
				be added to the function, without ever breaking existing code:
			</p>
<pre>
void API_func(TTAGITEM *tags)
{
    TINT numv = (TINT) TGetTag(tags, MY_NumPoints, (TTAG) 3);
    TFLOAT *v = (TFLOAT *) TGetTag(tags, MY_Points, def_vertices);
    TSTRPTR n = (TSTRPTR) TGetTag(tags, MY_Name, &quot;Def. Triangle&quot;);
    TUINT rgb = (TUINT) TGetTag(tags, MY_Color, (TTAG) 0xff0000);
    /* ... more tags in the future ... */
}
</pre>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							As the sizes of <code>TFLOAT</code> and <code>TDOUBLE</code> types are not regulated
							in TEKlib, they should be transported as pointer references. Aside
							from <code>TTAG</code> type values and pointers, only integers (up to the size
							of <code>TUINTPTR</code>) should be placed into the field <code>tti_Value</code>.
						</li>
					</ul>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h2><a name="lists" id="lists">Lists</a></h2>
			<p>
				TEKlib lists are doubly-linked, with a <em>stop node</em>, which appears
				before the first and after the last node of a list.
			</p>
			<p>
				The forward iterator for this topology looks like this:
			</p>
<pre>
struct TNode *next, *node = list-&gt;tlh_Head;
for (; (next = node-&gt;tln_Succ); node = next)
{
    /*
     * you can operate on 'node' here, remove it safely,
     * insert past it, as well as 'break' out from and
     * 'continue' the loop.
     */
}
</pre>
			<hr />
		</div>
		<div class="node"><h3><a name="teklib:TEKMain" id="teklib:TEKMain"><code>TEKMain()</code></a></h3>
<pre>
void TEKMain(struct TTask *task)
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					In a freestanding application, TEKlib resolves a platform-specific
					entrypoint like <code>main()</code> or intercepts the entrypoint provided by the
					platform's binary loader, performs initializations with reasonable
					defaults, and then enters <a href="#TEKMain"><code>TEKMain()</code></a>.
				</p>
				<p>
					Resources such as <code>argc</code>, <code>argv</code>, return values and other properties
					are made available to the framework in named atoms. See <a href="#TEKCreate"><code>TEKCreate()</code></a>,
					<a href="#util:TGetArgC"><code>util:TGetArgC()</code></a>, <a href="#util:TGetArgV"><code>util:TGetArgV()</code></a>, <a href="#util:TSetRetVal"><code>util:TSetRetVal()</code></a> for details.
				</p>
				<p>
					If you need more control over the startup procedure then you can
					write your own startup library using <a href="#TEKCreate"><code>TEKCreate()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>EXAMPLE</dfn>
				<p>
					Unless you write a more convenient C++ startup library of your own,
					the TEKlib application entrypoint for a C++ application would look
					like this:
				</p>
<pre>
extern &quot;C&quot; void TEKMain(struct TTask *task)
{
    /* ... */
}
</pre>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TEKCreate"><code>teklib:TEKCreate()</code></a>, <a href="#exec:TGetExecBase"><code>exec:TGetExecBase()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TEKCreate" id="teklib:TEKCreate"><code>TEKCreate()</code></a></h3>
<pre>
basetask = TEKCreate(tags)
struct TTask*        TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function creates an initial TEKlib context. All further
					functionality is related to and derived from this handle.
					If initialization fails, the return value is <code>TNULL</code>. If successful,
					the initial task handle refers to the process/thread context in which the
					caller is running. The handle is being destroyed with a call to
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>, which will clean up and free all resources.
				</p>
				<p>
					This kind of startup allows for integratation of TEKlib into
					foreign environments, and you can use it for writing your own
					startup library.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>basetask</code> - initial context handle.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>tags</code> - Pointer to an array of tag items, or <code>TNULL</code>.
							<blockquote>
								<ul>
									<li>
										<code>TExecBase_ArgC, (TUINT)</code> - Submit a <code>main()</code> entrypoint's
										number of arguments to the framework. If applicable, <code>argc</code>,
										<code>argv</code> will be made available in a named atom <code>sys.argv</code>. See
										also <a href="#util:TGetArgC"><code>util:TGetArgC()</code></a>. Default: undefined
									</li>
									<li>
										<code>TExecBase_ArgV, (TSTRPTR)</code> - Submit a <code>main()</code> entrypoint's
										array of arguments to the framework. If applicable, <code>argc</code>,
										<code>argv</code> will be made available in a named atom <code>sys.argv</code>.
										See also <a href="#util:TGetArgV"><code>util:TGetArgV()</code></a>. Default: undefined
									</li>
									<li>
										<code>TExecBase_RetValP, (TINT *)</code> - Submit a pointer to a possible
										return value. The pointer will be made available in a named atom
										<code>sys.returnvalue</code>. The variable being pointed to should be
										initialized with zero. See also <a href="#util:TSetRetVal"><code>util:TSetRetVal()</code></a> for setting the
										return value in an application. Default: undefined
									</li>
									<li>
										<code>TExecBase_ModInit, (struct TInitModule *)</code> - Submit a
										<code>TNULL</code>-terminated array of internal startup modules to your
										application. This allows you to link modules to applications
										statically. Internal modules will be looked up first, i.e. before
										any of the search strategies for modules from disk apply.
										Default: <code>TNULL</code> 
									</li>
									<li>
										<code>TExecBase_ProgDir, (TSTRPTR)</code> - Override the path to TEKlib's
										logical <code>PROGDIR:</code> volume, which by default resembles to the
										directory in which the application resides. Default: the
										application directory
									</li>
									<li>
										<code>TExecBase_ModDir, (TSTRPTR)</code> - Some platforms support this tag
										argument for setting a global search path for modules, overriding
										the hardcoded internal default (e.g. <code>/opt/tek/mod</code>). Local
										modules (those in <code>PROGDIR:mod</code>) are not affected, as those will
										always be probed first. Default: platform-specific.
									</li>
									<li>
										<code>TExecBase_SysDir, (TSTRPTR)</code> - Some platforms support this tag
										argument for setting a global system directory, overriding the
										hardcoded internal default (e.g.
										<code>C:\Programs\Common Shared Files\tek</code>), which also resembles to
										the logical <code>SYS:</code> volume in TEKlib's filesystem namespace.
										Default: platform-specific
									</li>
								</ul>
							</blockquote>
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							It is platform-specific whether you are allowed to create more than
							one instance of TEKlib per application. Most platforms currently
							supported do, but this would be something unadvisable to depend on.
						</li>
						<li>
							Applications running in the POSIX environment depend on the <code>argv</code> 
							vector to determine their logical program directory. You are advised
							to pass the tags <code>TExecBase_ArgC</code> and <code>TExecBase_ArgV</code>. If they are
							unavailable, use <code>TExecBase_ProgDir</code> to supply this information.
						</li>
						<li>
							Not all platforms support this kind of startup, since a fully-fledged
							TEKlib context cannot be described by the basetask handle alone. For
							example, if associating thread-specific data requires manipulation of
							the stack layout, then it is possible that the respective platform can
							only provide <a href="#TEKMain"><code>TEKMain()</code></a>.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TEKMain"><code>teklib:TEKMain()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TAddHead" id="teklib:TAddHead"><code>TAddHead()</code></a></h3>
<pre>
TAddHead(list,         node)
         struct TList* struct TNode *
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Add a node at the head of a doubly linked list.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>list</code> - Pointer to a list header
						</li>
						<li style="list-style-type: none">
							<code>node</code> - Pointer to a node to be added
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TAddTail"><code>teklib:TAddTail()</code></a>, <a href="#teklib:TInitList"><code>teklib:TInitList()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TAddTail" id="teklib:TAddTail"><code>TAddTail()</code></a></h3>
<pre>
TAddTail(list,         node)
         struct TList* struct TNode *
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Add a node at the tail of a doubly linked list.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>list</code> - Pointer to a list header
						</li>
						<li style="list-style-type: none">
							<code>node</code> - Pointer to a node to be added
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TAddHead"><code>teklib:TAddHead()</code></a>, <a href="#teklib:TInitList"><code>teklib:TInitList()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TRemove" id="teklib:TRemove"><code>TRemove()</code></a></h3>
<pre>
TRemove(node)
        struct TNode*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Unlink a node from whatever list it is linked to.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>node</code> - Pointer to a node to be removed
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							Using this function with a node not being part of a list will
							be fatal.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TRemHead"><code>teklib:TRemHead()</code></a>, <a href="#teklib:TRemTail"><code>teklib:TRemTail()</code></a>, <a href="#teklib:TInitList"><code>teklib:TInitList()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TRemHead" id="teklib:TRemHead"><code>TRemHead()</code></a></h3>
<pre>
node = TRemHead(list)
struct TNode*   struct TList*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Unlink and return the first node from a doubly linked list.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>node</code> - Pointer to the node being unlinked from the list,
							or <code>TNULL</code> 
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>list</code> - Pointer to a list header
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TRemTail"><code>teklib:TRemTail()</code></a>, <a href="#teklib:TRemove"><code>teklib:TRemove()</code></a>, <a href="#teklib:TInitList"><code>teklib:TInitList()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TRemTail" id="teklib:TRemTail"><code>TRemTail()</code></a></h3>
<pre>
node = TRemTail(list)
struct TNode*   struct TList*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Unlink and return the last node from a doubly linked list.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>node</code> - Pointer to the node being unlinked from the list,
							or <code>TNULL</code> 
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>list</code> - Pointer to a list header
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TRemHead"><code>teklib:TRemHead()</code></a>, <a href="#teklib:TRemove"><code>teklib:TRemove()</code></a>, <a href="#teklib:TInitList"><code>teklib:TInitList()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TDestroy" id="teklib:TDestroy"><code>TDestroy()</code></a></h3>
<pre>
TDestroy(handle)
         struct THandle*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Destroy a generic handle by calling its destructor. If either
					handle or <code>handle-&gt;thn_DestroyFunc</code> is <code>TNULL</code>, then nothing
					will happen.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>handle</code> - Pointer to a generic object handle
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							No memory whatsoever will be freed by this function
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TDestroyList"><code>teklib:TDestroyList()</code></a>, <a href="#teklib:TFindHandle"><code>teklib:TFindHandle()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TInitList" id="teklib:TInitList"><code>TInitList()</code></a></h3>
<pre>
TInitList(list)
          struct TList*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Prepare a list header structure. After initialization the list
					will be empty and ready for use.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>list</code> -  Pointer to a list structure
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TAddHead"><code>teklib:TAddHead()</code></a>, <a href="#teklib:TAddTail"><code>teklib:TAddTail()</code></a>, <a href="#teklib:TRemove"><code>teklib:TRemove()</code></a>, <a href="#teklib:TRemHead"><code>teklib:TRemHead()</code></a>,
					<a href="#teklib:TRemTail"><code>teklib:TRemTail()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TInsert" id="teklib:TInsert"><code>TInsert()</code></a></h3>
<pre>
TInsert(list,         node,         prednode)
        struct TList* struct TNode* struct TNode*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Insert a node into a list after prednode. If prednode
					is <code>TNULL</code>, then this function is equivalent to <a href="#teklib:TAddTail"><code>teklib:TAddTail()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>list</code> - Pointer to a list to insert to
						</li>
						<li style="list-style-type: none">
							<code>node</code> - Pointer to a node to insert
						</li>
						<li style="list-style-type: none">
							<code>prednode</code> - Pointer to a node in the list after which to insert
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TRemove"><code>teklib:TRemove()</code></a>, <a href="#teklib:TAddTail"><code>teklib:TAddTail()</code></a>, <a href="#teklib:TAddHead"><code>teklib:TAddHead()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TNodeUp" id="teklib:TNodeUp"><code>TNodeUp()</code></a></h3>
<pre>
TNodeUp(node)
        struct TNode*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Move a node one position towards the head of the list it is linked
					to. In other words, if the node is not already at the head of the
					list, swap its position with its predecessor.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>node</code> - Pointer to a node
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							Using this function with a node not being part of a list will
							be fatal.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TRemove"><code>teklib:TRemove()</code></a>, <a href="#teklib:TAddTail"><code>teklib:TAddTail()</code></a>, <a href="#teklib:TAddHead"><code>teklib:TAddHead()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TGetTag" id="teklib:TGetTag"><code>TGetTag()</code></a></h3>
<pre>
value = TGetTag(taglist,  tag,  defvalue)
TTAG            TTAGITEM* TUINT TTAG
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Parse a list of tag items and return the value associated with
					the first matching tag identifier. If the specified tag is not
					contained in the list, then the default value is returned.
				</p>
				<p>
					<a href="#taglists">taglists</a> are arrays of tagitems. Each tagitem is
					composed from a key/value pair. Many TEKlib functions accept
					a taglist argument for making them more robust for future
					extensions.
				</p>
				<p>
					The tag field can contain control tags and user tags. User tags
					must be combined with the TTAG_USER flag. Control tags are:
				</p>
				<ul>
					<li style="list-style-type: none">
						<code>TTAG_DONE</code> 
						<blockquote>
							<p>
								This is the last entry of the array. traversal
								stops here.
							</p>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>TTAG_IGNORE</code> 
						<blockquote>
							<p>
								This item is being ignored.
							</p>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>TTAG_SKIP</code> 
						<blockquote>
							<p>
								Skip this item plus the number of items contained in value.
							</p>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>TTAG_MORE</code> 
						<blockquote>
							<p>
								Value is a pointer to another array oftagitems.
								Traversal is continued at the new array, and does not return.
							</p>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>TTAG_GOSUB</code> 
						<blockquote>
							<p>
								Value is a pointer to another array of tagitems. After return
								from the sub-array, traversal continues here.
							</p>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>value</code> - Value associated with the tag in the taglist,
							otherwise the default value
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>taglist</code> - Pointer to an array of tag items
						</li>
						<li style="list-style-type: none">
							<code>tag</code> - Tag to be queried
						</li>
						<li style="list-style-type: none">
							<code>defvalue</code> - Default value
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							The <code>TTAG</code> type is capable of carrying pointers. This allows, in
							essence, to transport any kind of data in tag items, even on 64bit
							architectures. An unfortunate side-effect is that assigning a value to
							<code>tti_Value</code> may require a typecast to <code>TTAG</code> for getting rid of
							complaints from the compiler.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TForEachTag"><code>teklib:TForEachTag()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TDestroyList" id="teklib:TDestroyList"><code>TDestroyList()</code></a></h3>
<pre>
TDestroyList(list)
             struct TList*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Unlinks all nodes from a list (in first-to-last order) and calls
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a> on each individual entry. Note that this function
					expects all nodes (their heading structure) to be of the generic
					handle datatype, otherwise the consequences would be nasty.
				</p>
				<p>
					Nothing will happen if list is <code>TNULL</code> or if the list is empty.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>list</code> - list to clear
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>, <a href="#teklib:TFindHandle"><code>teklib:TFindHandle()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TNewInstance" id="teklib:TNewInstance"><code>TNewInstance()</code></a></h3>
<pre>
inst = TNewInstance(mod,  possize, negsize)
TAPTR               TAPTR TUINT    TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function creates a module instance copy. The module base
					can be duplicated alongside with a preceding function table.
				</p>
				<p>
					<code>possize</code> and {{negsize&#093;&#093; determine the size of the module base and the
					size of a preceding function table, respectively. Usually these
					arguments will be set to <code>mod-&gt;tmd_PosSize</code> and <code>mod-&gt;tmd_NegSize</code>,
					which will create an exact copy a of the module. However, it is also
					possible to extend the module base and function table.
				</p>
				<p>
					A pointer to the duplicated module base is returned.
					<a href="#teklib:TNewInstance"><code>teklib:TNewInstance()</code></a> is typically used in a module's instance open
					function.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>inst</code> - A copy of the module base and function table, or <code>TNULL</code> 
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>mod</code> - Pointer to module base
						</li>
						<li style="list-style-type: none">
							<code>possize</code> - Positive size of the module, in bytes
						</li>
						<li style="list-style-type: none">
							<code>negsize</code> - Negative size of the module, in bytes
						</li>
					</ul>
				</blockquote>
				<p>
					The negative size is the size of the function table that
					normally precedes the module base.
				</p>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TFreeInstance"><code>teklib:TFreeInstance()</code></a>, <a href="#teklib:TInitVectors"><code>teklib:TInitVectors()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TFreeInstance" id="teklib:TFreeInstance"><code>TFreeInstance()</code></a></h3>
<pre>
TFreeInstance(inst)
              struct TModule *
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function frees a module instance. It respects the size of the
					module base as well as its negative size, that is, the size of the
					function table preceding it.
				</p>
				<p>
					This function is normally used in a module's instance close
					function.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>inst</code> - Pointer to a module instance
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TNewInstance"><code>teklib:TNewInstance()</code></a>, <a href="#teklib:TInitVectors"><code>teklib:TInitVectors()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TInitVectors" id="teklib:TInitVectors"><code>TInitVectors()</code></a></h3>
<pre>
TInitVectors(mod,  vectors, numv)
             TAPTR TAPTR*   TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function takes a pointer to a table of function pointers
					and places them in front of a module base (in reverse order -
					a simple memory copy would be inappropriate here). This function
					is normally used in a module's init function.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>mod</code> - Module base pointer
						</li>
						<li style="list-style-type: none">
							<code>vectors</code> - Pointer to a table of function pointers
						</li>
						<li style="list-style-type: none">
							<code>numv</code> - Number of entries
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<blockquote>
					<p>
						<a href="#teklib:TNewInstance"><code>teklib:TNewInstance()</code></a>, <a href="#teklib:TFreeInstance"><code>teklib:TFreeInstance()</code></a> 
					</p>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TFindHandle" id="teklib:TFindHandle"><code>TFindHandle()</code></a></h3>
<pre>
handle = TFindHandle(list,  name)
TAPTR                TLIST* TSTRPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Find the first occurance of a named handle in a list. The name
					is expected in each node's handle-&gt;thn_Data field. Only <a href="#lists">lists</a> 
					containing only nodes with a conforming object handle may be
					searched with this function. Name comparison is case-sensitive.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>handle</code> - Ptr to named handle, or TNULL if not found in the list
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>list</code> - Pointer to a list structure
						</li>
						<li style="list-style-type: none">
							<code>name</code> - Name of a handle to look up
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>, <a href="#teklib:TDestroyList"><code>teklib:TDestroyList()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TForEachTag" id="teklib:TForEachTag"><code>TForEachTag()</code></a></h3>
			<p>
				(TODO)
			</p>
<pre>
complete = TForEachTag(taglist,  function,       userdata)
TBOOL                  TTAGITEM* TTAGFOREACHFUNC TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function traverses a list of tagitems, and for each item it
					calls a user-supplied function according of the following type:
				</p>
<pre>
TCALLBACK TBOOL function(TAPTR userdata, TTAGITEM *item)
</pre>
				<p>
					The <code>userdata</code> argument is passed to the callback function and
					otherwise remains invisible to <a href="#TForEachTag"><code>TForEachTag()</code></a>. The callback function
					has to return TTRUE to continue traversal, or TFALSE to abort.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>complete</code> - TTRUE if the list was traversed completely
						</li>
					</ul>
				</blockquote>
				<p>
					When all items were traversed without interruption, then the
					return value from <a href="#TForEachTag"><code>TForEachTag()</code></a> will be <code>TTRUE</code>. <code>TFALSE</code> will be
					returned otherwise.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>taglist</code> - an array of tagitems to traverse
						</li>
						<li style="list-style-type: none">
							<code>function</code> - callback function to call for each item traversed
						</li>
						<li style="list-style-type: none">
							<code>userdata</code> - user data argument passed to the callback function
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TGetTag"><code>teklib:TGetTag()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TInitHook" id="teklib:TInitHook"><code>TInitHook()</code></a></h3>
<pre>
TInitHook(hook,         func,     data)
          struct THook* THOOKFUNC TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Initialize a hook structure with a function and user data.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>hook</code> - Hook structure to be initialized
						</li>
						<li style="list-style-type: none">
							<code>func</code> - C calling conventions function pointer
						</li>
						<li style="list-style-type: none">
							<code>data</code> - User data to be associated with the hook
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>PURPOSE</dfn>
				<p>
					TEKlib hooks allow the transparent transition from e.g. register- to
					stack-based calling conventions. <code>hook-&gt;thk_Entry</code> is invoked by
					<a href="#teklib:TCallHookPkt"><code>teklib:TCallHookPkt()</code></a> and follows TEKlib's per-platform calling
					conventions (as declared with <code>THOOKENTRY</code>). It however may point
					to a stub function calling the actual user function in
					<code>hook-&gt;thk_SubEntry</code>, which in turn may be entirely specific for
					the used language or compiler.
				</p>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TCallHookPkt"><code>teklib:TCallHookPkt()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TCallHookPkt" id="teklib:TCallHookPkt"><code>TCallHookPkt()</code></a></h3>
<pre>
result = TCallHookPkt(hook,         object, message)
TTAG                  struct THook* TAPTR   TTAG
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Invokes a hook function, passing it an <code>object</code> and <code>message</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>result</code> - specific to the invoked hook function
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>object</code> - An object to be processed by the hook
						</li>
						<li style="list-style-type: none">
							<code>message</code> - An action code
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							TEKlib hooks are commonly used for destructors, hashing functions,
							module initialization, task creation, tag iterators etc. Therefore,
							TEKlib comes with a range of pre-defined hook message types, such as
							<code>TMSG_DESTROY</code>, <code>TMSG_CALCHASH32</code>, <code>TMSG_OPENMODULE</code>,
							<code>TMSG_INITTASK</code>, <code>TMSG_FOREACHTAG</code>, to name only examples.
							User-defined messages start at <code>TMSG_USER</code>, but the user is free to
							bypass TEKlib's message codes altogether by seperating system hooks
							from his own.
						</li>
					</ul>
				</blockquote>
				<p>
					SEE ALSO:
					<a href="#teklib:TInitHook"><code>teklib:TInitHook()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TAddTime" id="teklib:TAddTime"><code>TAddTime()</code></a></h3>
<pre>
TAddTime(a,     b)
         TTIME* TTIME*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Add time <code>b</code> to time <code>a</code>, leaving the result in time <code>a</code>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>a</code> - Pointer to a time structure to add to
						</li>
						<li style="list-style-type: none">
							<code>b</code> - Pointer to a time structure to be added
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TSubTime"><code>teklib:TSubTime()</code></a>, <a href="#teklib:TCmpTime"><code>teklib:TCmpTime()</code></a>, <a href="#teklib:TAddDate"><code>teklib:TAddDate()</code></a>,
					<a href="#teklib:CreateTime"><code>teklib:CreateTime()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TSubTime" id="teklib:TSubTime"><code>TSubTime()</code></a></h3>
<pre>
TSubTime(a,     b)
         TTIME* TTIME*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Subtract time <code>b</code> from time <code>a</code>, leaving the result in time <code>a</code>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>a</code> - Pointer to a time structure to subtract from
						</li>
						<li style="list-style-type: none">
							<code>b</code> - Pointer to a time structure to be subtracted
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TAddTime"><code>teklib:TAddTime()</code></a>, <a href="#teklib:TCmpTime"><code>teklib:TCmpTime()</code></a>, <a href="#teklib:TSubDate"><code>teklib:TSubDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TCmpTime" id="teklib:TCmpTime"><code>TCmpTime()</code></a></h3>
<pre>
res = TCmpTime(a,     b)
TINT           TTIME* TTIME*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Compare time <code>a</code> with time <code>b</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>res</code> - result of comparison:
							<blockquote>
								<ul>
									<li>
										<code>1</code> - if time a refers to a later point in time than time b
									</li>
									<li>
										<code>-1</code> - if time a refers to a earlier point in time than time b
									</li>
									<li>
										<code>0</code> - if time a is equal to time b.
									</li>
								</ul>
							</blockquote>
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>a</code> - Pointer to a time structure, first operand
						</li>
						<li style="list-style-type: none">
							<code>b</code> - Pointer to a time structure, second operand
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TAddTime"><code>teklib:TAddTime()</code></a>, <a href="#teklib:TSubTime"><code>teklib:TSubTime()</code></a>, <a href="#teklib:TDiffDate"><code>teklib:TDiffDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TAddDate" id="teklib:TAddDate"><code>TAddDate()</code></a></h3>
<pre>
TAddDate(date,  ndays, time)
         TDATE* TINT   TTIME*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Add a number of days and optionally a time to a date.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>tdate</code> - Date structure
						</li>
						<li style="list-style-type: none">
							<code>ndays</code> - Number of days to add. Can be 0.
						</li>
						<li style="list-style-type: none">
							<code>time</code> - Pointer to a TTIME structure. Can be TNULL.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							Do not add negative values in the time structure, use
							the function <a href="#teklib:TSubDate"><code>teklib:TSubDate()</code></a> instead.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TSubDate"><code>teklib:TSubDate()</code></a>, <a href="#teklib:TDiffDate"><code>teklib:TDiffDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TSubDate" id="teklib:TSubDate"><code>TSubDate()</code></a></h3>
<pre>
TSubDate(date,  ndays, time)
         TDATE* TINT   TTIME*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Subtract a number of days and optionally a time from a date.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>tdate</code> - Date structure
						</li>
						<li style="list-style-type: none">
							<code>ndays</code> - Number of days to subtract. Can be 0.
						</li>
						<li style="list-style-type: none">
							<code>time</code> - Pointer to a TTIME structure. Can be TNULL.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							Do not subtract negative values in the time structure,
							use the function <a href="#TAddDate"><code>TAddDate()</code></a> instead.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TAddDate"><code>teklib:TAddDate()</code></a>, <a href="#teklib:TDiffDate"><code>teklib:TDiffDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TDiffDate" id="teklib:TDiffDate"><code>TDiffDate()</code></a></h3>
<pre>
days = TDiffDate(date1, date2, timep)
TINT             TDATE* TDATE* TTIME*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function returns the difference in number of days between
					date1 and date2. The difference in time will be inserted,
					optionally, into the time structure being pointed to by timep.
				</p>
				<p>
					Note that if date1 is before date2, the resulting number
					of days will be negative, but the time difference (in seconds
					and microseconds) will always be inserted as positive numbers.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>days</code> - Number of days difference
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>date1, date2</code> - Pointers to TDATE structures
						</li>
						<li style="list-style-type: none">
							<code>timep</code> - Pointer to a <code>TTIME</code> structure receiving a
							time difference, or <code>TNULL</code> 
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TAddDate"><code>teklib:TAddDate()</code></a>, <a href="#teklib:TSubDate"><code>teklib:TSubDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TCreateTime" id="teklib:TCreateTime"><code>TCreateTime()</code></a></h3>
<pre>
success = TCreateTime(timep, d,   s,   us)
TBOOL                 TTIME* TINT TINT TINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function composes a TEKlib time from days, seconds and microseconds.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>success</code> - Boolean
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>timep</code> - Pointer to a <code>TIME</code> structure receiving the result
						</li>
						<li style="list-style-type: none">
							<code>d</code> - Number of days
						</li>
						<li style="list-style-type: none">
							<code>s</code> - Number of seconds
						</li>
						<li style="list-style-type: none">
							<code>us</code> - Number of microseconds
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:ExtractTime"><code>teklib:ExtractTime()</code></a>, <a href="#teklib:AddTime"><code>teklib:AddTime()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TExtractTime" id="teklib:TExtractTime"><code>TExtractTime()</code></a></h3>
<pre>
success = TExtractTime(timep, dp,   sp,   usp)
TBOOL                  TTIME* TINT* TINT* TINT*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function extracts from a TEKlib time the number of days, seconds
					and microseconds.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>success</code> - Boolean
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>timep</code> - Pointer to a <code>TIME</code> structure
						</li>
						<li style="list-style-type: none">
							<code>dp</code> - Pointer to a number of days, or <code>TNULL</code> 
						</li>
						<li style="list-style-type: none">
							<code>sp</code> - Pointer to a number of seconds, or <code>TNULL</code> 
						</li>
						<li style="list-style-type: none">
							<code>usp</code> - Pointer to a number of microseconds, or <code>TNULL</code> 
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TCreateTime"><code>teklib:TCreateTime()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TInitInterface" id="teklib:TInitInterface"><code>TInitInterface()</code></a></h3>
<pre>
TInitInterface(interface,         module,         name,   version)
               struct TInterface* struct TModule* TSTRPTR TUINT16
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function initializes an interface structure.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>interface</code> - Pointer to an <code>TInterface</code> structure
						</li>
						<li style="list-style-type: none">
							<code>module</code> - Pointer to a <code>TModule</code> structure to which the
							interface belongs
						</li>
						<li style="list-style-type: none">
							<code>name</code> - Name of the interface
						</li>
						<li style="list-style-type: none">
							<code>version</code> - Version of the interface
						</li>
					</ul>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="teklib:TGetNextEntry" id="teklib:TGetNextEntry"><code>TGetNextEntry()</code></a></h3>
<pre>
entry = TGetNextEntry(handle)
TAPTR                 struct THandle*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Get the next entry from a handle by dispatching TMSG_GETNEXTENTRY.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>entry</code> - Next entry, or <code>TNULL</code> if no next entry available
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>handle</code> - Pointer to a generic object handle
						</li>
					</ul>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h2><a name="string" id="string">string </a></h2>
			<div class="definition"><dfn>FUNCTIONS</dfn>
				<ul>
					<li style="list-style-type: none">
						<a href="#string:TStrCaseCmp"><code>string:TStrCaseCmp()</code></a> - Compare strings, case-insensitive
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrCat"><code>string:TStrCat()</code></a> - Append string
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrChr"><code>string:TStrChr()</code></a> - Find character in a string
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrCmp"><code>string:TStrCmp()</code></a> - Compare strings
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrCpy"><code>string:TStrCpy()</code></a> - Copy string
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrLen"><code>string:TStrLen()</code></a> - Return length of a string
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrNCaseCmp"><code>string:TStrNCaseCmp()</code></a> - Compare strings, case-insensitive, length-limited
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrNCat"><code>string:TStrNCat()</code></a> - Append string, length-limited
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrNCmp"><code>string:TStrNCmp()</code></a> - Compare strings, length-limited
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrNCpy"><code>string:TStrNCpy()</code></a> - Copy string, length-limited
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrRChr"><code>string:TStrRChr()</code></a> - Find character in a string from the end
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrStr"><code>string:TStrStr()</code></a> - Find substring in a string
					</li>
					<li style="list-style-type: none">
						<a href="#string:TStrToI"><code>string:TStrToI()</code></a> - Convert string to integer
					</li>
				</ul>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="string:TStrLen" id="string:TStrLen"><code>TStrLen()</code></a></h3>
<pre>
len = TStrLen(string)
TSIZE         TSTRPTR
</pre>
			<hr />
		</div>
		<div class="node"><h3><a name="string:TStrCpy" id="string:TStrCpy"><code>TStrCpy()</code></a></h3>
<pre>
dest = TStrCpy(dest,   source)
TSTRPTR        TSTRPTR TSTRPTR
</pre>
			<hr />
		</div>
		<div class="node"><h3><a name="string:TStrNCpy" id="string:TStrNCpy"><code>TStrNCpy()</code></a></h3>
<pre>
dest = TStrNCpy(dest,   source, maxlen)
TSTRPTR         TSTRPTR TSTRPTR TSIZE
</pre>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							If the length of <code>source</code> is less than <code>maxlen</code>, this
							function does not pad the remainder of dest with null bytes.
							This is in contrast to the <a href="#strncpy"><code>strncpy()</code></a> standard library function.
						</li>
					</ul>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="string:TStrCat" id="string:TStrCat"><code>TStrCat()</code></a></h3>
<pre>
dest = TStrCat(dest,   source)
TSTRPTR        TSTRPTR TSTRPTR
</pre>
			<hr />
		</div>
		<div class="node"><h3><a name="string:TStrNCat" id="string:TStrNCat"><code>TStrNCat()</code></a></h3>
<pre>
dest = TStrNCat(dest,   source, maxlen)
TSTRPTR         TSTRPTR TSTRPTR TSIZE
</pre>
			<hr />
		</div>
		<div class="node"><h3><a name="string:TStrCmp" id="string:TStrCmp"><code>TStrCmp()</code></a></h3>
<pre>
res = TStrCmp(first,  second)
TINT          TSTRPTR TSTRPTR
</pre>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							Either or both strings may be <code>TNULL</code>. A <code>TNULL</code> string is
							'less than' a non-<code>TNULL</code> string.
						</li>
					</ul>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="string:TStrNCmp" id="string:TStrNCmp"><code>TStrNCmp()</code></a></h3>
<pre>
res = TStrNCmp(first,  second, maxlen)
TINT           TSTRPTR TSTRPTR TSIZE
</pre>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<p>
						See annotations for <a href="#string:TStrCmp"><code>string:TStrCmp()</code></a> 
					</p>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="string:TStrCaseCmp" id="string:TStrCaseCmp"><code>TStrCaseCmp()</code></a></h3>
<pre>
res = TStrCaseCmp(first,  second)
TINT              TSTRPTR TSTRPTR
</pre>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<p>
						See annotations for <a href="#string:TStrCmp"><code>string:TStrCmp()</code></a> 
					</p>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="string:TStrNCaseCmp" id="string:TStrNCaseCmp"><code>TStrNCaseCmp()</code></a></h3>
<pre>
res = TStrNCaseCmp(first,  second, maxlen)
TINT               TSTRPTR TSTRPTR TSIZE
</pre>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<p>
						See annotations for <a href="#string:TStrCmp"><code>string:TStrCmp()</code></a> 
					</p>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="string:TStrStr" id="string:TStrStr"><code>TStrStr()</code></a></h3>
<pre>
found = TStrStr(haystack, needle)
TSTRPTR         TSTRPTR   TSTRPTR
</pre>
			<hr />
		</div>
		<div class="node"><h3><a name="string:TStrChr" id="string:TStrChr"><code>TStrChr()</code></a></h3>
<pre>
found = TStrChr(string, character)
TSTRPTR         TSTRPTR TINT
</pre>
			<hr />
		</div>
		<div class="node"><h3><a name="string:TStrRChr" id="string:TStrRChr"><code>TStrRChr()</code></a></h3>
<pre>
found = TStrRChr(string, character)
TSTRPTR          TSTRPTR TINT
</pre>
			<hr />
		</div>
		<div class="node"><h3><a name="string:TStrToI" id="string:TStrToI"><code>TStrToI()</code></a></h3>
<pre>
numchars = TStrToI(string, valp)
TINT               TSTRPTR TINT*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function converts a string to a 32bit signed integer.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>numchars</code> - Number of characters converted, or:
							<blockquote>
								<ul>
									<li>
										<code>-1</code> - Conversion error, invalid characters
									</li>
									<li>
										<code>-2</code> - Overflow or underflow occured
									</li>
								</ul>
							</blockquote>
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>string</code> - Pointer to a string to be converted
						</li>
						<li style="list-style-type: none">
							<code>valp</code> - Pointer to a value to be filled in by this function
						</li>
					</ul>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h2><a name="exec" id="exec">exec </a></h2>
			<div class="definition"><dfn>FUNCTIONS</dfn>
				<ul>
					<li style="list-style-type: none">
						<a href="#exec:TAbortIO"><code>exec:TAbortIO()</code></a> - Ask for abortion of an I/O packet
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a> - Acknowledge a message to its sender
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TAlloc"><code>exec:TAlloc()</code></a> - Allocate memory
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TAlloc0"><code>exec:TAlloc0()</code></a> - Allocate memory, blank
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a> - Allocate memory for a message
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TAllocMsg0"><code>exec:TAllocMsg0()</code></a> - Allocate memory for a message, blank
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TAllocPool"><code>exec:TAllocPool()</code></a> - Allocate memory from a pooled allocator
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TAllocSignal"><code>exec:TAllocSignal()</code></a> - Allocate a signal bit from a task
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TAllocTimeRequest"><code>exec:TAllocTimeRequest()</code></a> - Allocate a timer device request
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCheckIO"><code>exec:TCheckIO()</code></a> - Check for completion of an I/O packet
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCloseModule"><code>exec:TCloseModule()</code></a> - Close a module or module instance
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCopyMem"><code>exec:TCopyMem()</code></a> - Copy memory
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCreateLock"><code>exec:TCreateLock()</code></a> - Create locking object for sharing a resource
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a> - Create a memory manager
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCreatePool"><code>exec:TCreatePool()</code></a> - Create pooled memory allocator
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCreatePort"><code>exec:TCreatePort()</code></a> - Create a message port for communication
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCreateSysTask"><code>exec:TCreateSysTask()</code></a> - Create Exec system task
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TCreateTask"><code>exec:TCreateTask()</code></a> - Create a new thread of execution
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TDoExec"><code>exec:TDoExec()</code></a> - Perform initializations and service Exec system tasks
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TDoIO"><code>exec:TDoIO()</code></a> - Send (and wait for) an I/O packet synchronously
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TDropMsg"><code>exec:TDropMsg()</code></a> - Make a message fail at its sender
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TFillMem"><code>exec:TFillMem()</code></a> - Fill memory
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TFindTask"><code>exec:TFindTask()</code></a> - Find own or a named task
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TFree"><code>exec:TFree()</code></a> - Free memory
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TFreePool"><code>exec:TFreePool()</code></a> - Return memory to a pool
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TFreeSignal"><code>exec:TFreeSignal()</code></a> - Return an allocated signal bit to a task
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TFreeTimeRequest"><code>exec:TFreeTimeRequest()</code></a> - Free a timer device request
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetAtomData"><code>exec:TGetAtomData()</code></a> - Get data associated with an atom
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetExecBase"><code>exec:TGetExecBase()</code></a> - Get Exec module base pointer
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetHALBase"><code>exec:TGetHALBase()</code></a> - Get HAL module base pointer
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetLocalDate"><code>exec:TGetLocalDate()</code></a> - Get system's local date and time
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetMemManager"><code>exec:TGetMemManager()</code></a> - Get an allocation's memory manager
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetMsg"><code>exec:TGetMsg()</code></a> - Get a message from a message port
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetPortSignal"><code>exec:TGetPortSignal()</code></a> - Get a message port's underlying signal bit
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetSize"><code>exec:TGetSize()</code></a> - Get size of an allocation
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetSyncPort"><code>exec:TGetSyncPort()</code></a> - Get a task's port for synchronized messages
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetSystemTime"><code>exec:TGetSystemTime()</code></a> - Get a (relative) system time
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetTaskData"><code>exec:TGetTaskData()</code></a> - Get a task's user data pointer
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetTaskMemManager"><code>exec:TGetTaskMemManager()</code></a> - Get a task's memory manager
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetUniversalDate"><code>exec:TGetUniversalDate()</code></a> - Get universal date and time (UTC)
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TGetUserPort"><code>exec:TGetUserPort()</code></a> - Get a task's inbuilt user message port
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TLock"><code>exec:TLock()</code></a> - Gain access to a shared resource
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TLockAtom"><code>exec:TLockAtom()</code></a> - Gain access to a named atom
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TOpenModule"><code>exec:TOpenModule()</code></a> - Open a module or module instance
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TPutIO"><code>exec:TPutIO()</code></a> - Put an I/O packet to a device or handler, asynchronously
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a> - Send a message to a task, asynchronously
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TQueryInterface"><code>exec:TQueryInterface()</code></a> - Obtain an interface from an open module
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TRealloc"><code>exec:TRealloc()</code></a> - Resize an allocated block of memory
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TReallocPool"><code>exec:TReallocPool()</code></a> - Resize an allocation made from a pool
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a> - Return a modified message to its sender
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TScanModules"><code>exec:TScanModules()</code></a> - Scan available TEKlib modules
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TSendMsg"><code>exec:TSendMsg()</code></a> - Send a message synchronously
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TSetAtomData"><code>exec:TSetAtomData()</code></a> - Set data associated with an atom
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TSetSignal"><code>exec:TSetSignal()</code></a> - Set and get a task's signal state
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TSetTaskData"><code>exec:TSetTaskData()</code></a> - Set a task's user data pointer
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TSignal"><code>exec:TSignal()</code></a> - Submit signals to a task
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TUnlock"><code>exec:TUnlock()</code></a> - Release access to a shared resource
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TUnlockAtom"><code>exec:TUnlockAtom()</code></a> - Release access to a named atom
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TWait"><code>exec:TWait()</code></a> - Wait for signals
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TWaitDate"><code>exec:TWaitDate()</code></a> - Wait for an absolute date or a set of signals
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TWaitIO"><code>exec:TWaitIO()</code></a> - Wait for completion of an I/O packet
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TWaitPort"><code>exec:TWaitPort()</code></a> - Wait for a single message port
					</li>
					<li style="list-style-type: none">
						<a href="#exec:TWaitTime"><code>exec:TWaitTime()</code></a> - Wait for a timeout or a set of signals
					</li>
				</ul>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetExecBase" id="exec:TGetExecBase"><code>TGetExecBase()</code></a></h3>
<pre>
TExecBase = TGetExecBase(object)
struct TExecBase*        TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This macro retrieves a pointer to the Exec module base from an Exec
					object. Objects provided by the Exec module are tasks, ports, memory
					managers, atoms, locks, and modules themselves.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>TExecBase</code> - Pointer to the Exec module base
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>object</code> - Pointer to an Exec object
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>BACKGROUND</dfn>
				<p>
					The TEKlib framework is free of global data and carefully designed
					to be fully reentrant. It is the programmer's choice to put module
					base pointers into global variables.
				</p>
				<p>
					Initially, an application is entered with a task handle only. It
					is usually required to query the Exec module base pointer from that
					handle before anything useful can be done. The module base pointer
					can then be stored in a global variable, if desired. A typical
					application startup may look like this:
				</p>
<pre>
struct TExecBase *TExecBase;
struct TUtilBase *TUtilBase;

void TEKMain(struct TTask *task)
{
    TExecBase = TGetExecBase(task);
    TUtilBase = TOpenModule(&quot;util&quot;, ...
    ...
}
</pre>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetHALBase"><code>exec:TGetHALBase()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TDoExec" id="exec:TDoExec"><code>TDoExec()</code></a></h3>
<pre>
success = TDoExec(cmd,  tags)
TBOOL             TUINT TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Runs or initializes an Exec context. Depending on the <code>cmd</code> 
					argument, <a href="#TDoExec"><code>TDoExec()</code></a> performs missing initializations in the current task
					or services module opens, task creation and atom lookups.
					It is expected that the thread context in which this function is called
					was previously created using <a href="#exec:TCreateSysTask"><code>exec:TCreateSysTask()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>success</code> - Boolean
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>cmd</code> - Type of service to provide:
						<blockquote>
							<ul>
								<li>
									<code>TEXEC_CMD_INIT</code> - Performs initializations that qualify the
									current context as TEKlib's main application task. After returning,
									the user function can be called in a fully-fledged Exec context.
								</li>
								<li>
									<code>TEXEC_CMD_EXIT</code> - Performs the required steps to shut down and
									free all resources in the application task
								</li>
								<li>
									<code>TEXEC_CMD_RUN</code> - If the caller's task name is <code>TTASKNAME_EXEC</code> 
									(<code>&quot;exec&quot;</code>) then this function will serve module opens, task creation
									and atom lookups, requested through the message port
									<code>execbase-&gt;texb_ExecPort</code>. If the name is <code>TTASKNAME_RAMLIB</code> 
									(<code>&quot;ramlib&quot;</code>), this function will serve requests for loading
									modules, submitted to the task's userport. Either way, it returns to
									the caller when it receives the signal <code>TTASK_SIG_ABORT</code>.
								</li>
							</ul>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items (none currently defined)
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<p>
					This function is of any use only for implementors of startup libraries.
				</p>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TCreateSysTask"><code>exec:TCreateSysTask()</code></a>, <a href="#exec:TCreateTask"><code>exec:TCreateTask()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCreateSysTask" id="exec:TCreateSysTask"><code>TCreateSysTask()</code></a></h3>
<pre>
task = TCreateSysTask(func,     tags)
struct TTask*         TTASKFUNC TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function creates an Exec-internal task. If <code>func</code> is <code>TNULL</code>,
					a TEKlib task is placed in the caller's thread context, otherwise a new
					thread of execution is started at the given function.
				</p>
				<p>
					This function is used to setup an initial TEKlib context (or an
					Exec task) before TEKlib is fully initialized. This function is
					not entirely safe in regular applications and the only sanctioned
					use is in startup libraries.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Task handle, or <code>TNULL</code> if initialization failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>func</code> - Pointer to a thread entry function, or <code>TNULL</code> for the
						current context
					</li>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items:
						<blockquote>
							<ul>
								<li>
									<code>TTask_Name (TSTRPTR)</code> - Pointer to a string for the task name.
									Default: <code>TNULL</code> 
								</li>
								<li>
									<code>TTask_UserData (TAPTR)</code> - Pointer to an initial user data packet.
									Default: <code>TNULL</code> 
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						This function is for internal use only. Regular applications require
						only <a href="#exec:TCreateTask"><code>exec:TCreateTask()</code></a>.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TCreateTask"><code>exec:TCreateTask()</code></a>, <a href="#exec:TDoExec"><code>exec:TDoExec()</code></a>, <a href="#exec:TGetTaskData"><code>exec:TGetTaskData()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetHALBase" id="exec:TGetHALBase"><code>TGetHALBase()</code></a></h3>
<pre>
THALBase = TGetHALBase()
struct THALBase *
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Returns a pointer to the HAL module base. Access to the HAL layer is
					often required in device driver implementations.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>THALBase</code> - HAL module base pointer
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetExecBase"><code>exec:TGetExecBase()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TOpenModule" id="exec:TOpenModule"><code>TOpenModule()</code></a></h3>
<pre>
modbase = TOpenModule(name,   version, tags)
struct TModule*       TSTRPTR TUINT16  TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Opens a module or a module instance. When the module's version is
					greater or equal the requested version and when the module can be
					loaded and initialized successfully, a pointer to the module base
					will be returned to the caller.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>modbase</code> - Module base or <code>TNULL</code>. <code>TNULL</code> is returned if
						the module could not be found, when it failed to initialize or when
						the version requirement could not be satisfied.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>name</code> - Name of the module
					</li>
					<li style="list-style-type: none">
						<code>version</code> - Minimal module version for the open to succeed
					</li>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items. Tags passed to
						this function are passed to the module open function and can be
						intercepted there. There are currently no tags defined for
						<a href="#exec:TOpenModule"><code>exec:TOpenModule()</code></a> itself.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Each successful open to a module must be paired with exactly one
						matching call to <a href="#TCloseModule"><code>TCloseModule()</code></a>, or TEKlib will panic at exit.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TCloseModule"><code>exec:TCloseModule()</code></a>, <a href="#exec:TGetExecBase"><code>exec:TGetExecBase()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCloseModule" id="exec:TCloseModule"><code>TCloseModule()</code></a></h3>
<pre>
TCloseModule(modbase)
             struct TModule *
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Closes a module or a module instance. When applied to the last
					reference or instance open then the module will be deinitalized,
					unloaded and freed.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>module</code> - Module or module instance. It is safe to pass <code>TNULL</code>.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TOpenModule"><code>exec:TOpenModule()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCopyMem" id="exec:TCopyMem"><code>TCopyMem()</code></a></h3>
<pre>
TCopyMem(source, dest, numbytes)
         TAPTR   TAPTR TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Copy the given number of bytes from a source to a destination address
					in memory.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>source</code> - Source address
					</li>
					<li style="list-style-type: none">
						<code>dest</code> - Destination address
					</li>
					<li style="list-style-type: none">
						<code>numbytes</code> - Number of bytes to copy
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<ul>
						<li>
							Do not rely on overlapping copies to work with this function.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TFillMem"><code>exec:TFillMem()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TFillMem" id="exec:TFillMem"><code>TFillMem()</code></a></h3>
<pre>
TFillMem(start, numbytes, fillval)
         TAPTR  TSIZE     TUINT8
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Fill a range of memory with a 8bit value.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>start</code> - Start address in memory
					</li>
					<li style="list-style-type: none">
						<code>numbytes</code> - Number of bytes to fill
					</li>
					<li style="list-style-type: none">
						<code>fillval</code> - 8bit value
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#TCopyMem"><code>TCopyMem()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCreateMemManager" id="exec:TCreateMemManager"><code>TCreateMemManager()</code></a></h3>
<pre>
memmanager = TCreateMemManager(resource, type, tags)
struct TMemManager*            TAPTR     TUINT TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Create a memory manager. A memory manager can be passed to <a href="#exec:TAlloc"><code>exec:TAlloc()</code></a> 
					for allocating memory with special functionality attached to it, such as
					automatic cleanup, tighter packing, thread-safety, etc. Memory managers
					can be stacked on top of each other.
					A memory manager is freed with a call to <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>.
				</p>
				<p>
					<code>TNULL</code> is always a valid memory manager. A <code>TNULL</code> memory manager
					will cause <a href="#exec:TAlloc"><code>exec:TAlloc()</code></a> to use the system's general purpose allocator.
					Only a <code>TNULL</code> memory manager is intrinsically safe to use in a
					multitasking environment; other allocators must implement cross-task
					protection explicitely. See the <code>TMMT_TaskSafe</code> flag for details.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>memmanager</code> - Memory manager, or <code>TNULL</code> if initialization failed.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>resource</code> - Memory resource object, parent memory manager or <code>TNULL</code> 
					</li>
					<li style="list-style-type: none">
						<code>type</code> - Type of memory manager to be created:
						<blockquote>
							<ul>
								<li>
									<code>TMMT_MemManager</code> - Setup a memory manager on top of another,
									implementing no additional functionality. <code>resource</code> must be
									<code>TNULL</code> or point to another memory manager.
								</li>
								<li>
									<code>TMMT_TaskSafe</code> - Setup a memory manager implementing
									thread-safety. Multiple tasks are allowed to operate on the resulting
									memory manager at the same time.
								</li>
								<li>
									<code>TMMT_Tracking</code> - Setup a tracking memory manager. The resulting
									memory manager will return all pending allocations to its parent when
									it is being destroyed, at the cost of extra performance and resource
									usage. This type can be combined with <code>TMMT_TaskSafe</code>.
								</li>
								<li>
									<code>TMMT_Static</code> - The resulting memory manager will manage a static
									block of memory. When the block is exhausted or fragmented, further
									allocations will fail, as no attempts are made to get more storage from
									the outside. <code>resource</code> must be a pointer to a block of memory or
									<code>TNULL</code>. The tag <code>TMem_StaticSize</code> must be specified in the
									taglist as well (see below). This type can be combined with
									<code>TMMT_TaskSafe</code>.
								</li>
								<li>
									<code>TMMT_Pooled</code> - The resulting memory manager will group small
									allocations into larger ones. All pending allocations will be freed
									when the memory manager is being destroyed. <code>resource</code> must be a
									pointer to a pool created with <a href="#exec:TCreatePool"><code>exec:TCreatePool()</code></a> or <code>TNULL</code>. In
									the latter case, a pooled allocator will be created and maintained
									internally with the resulting memory manager, and any pool-specific
									tags passed to this function will be used accordingly. See
									<a href="#exec:TCreatePool"><code>exec:TCreatePool()</code></a> for details. This type can be combined with
									<code>TMMT_TaskSafe</code>.
								</li>
								<li>
									<code>TMMT_Void</code> - The resulting memory manager will be incapable of
									allocating memory. Attempts to do so will always return <code>TNULL</code>.
									This type can be useful for debugging purposes.
								</li>
							</ul>
						</blockquote>
					</li>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items:
						<blockquote>
							<ul>
								<li>
									<code>TMem_StaticSize, (TSIZE)</code> - This argument is mandatory when
									<code>type</code> is <code>TMMT_Static</code>. The value specifies the size of the
									block of memory to be managed. <code>resource</code> must be a pointer to a
									block of memory of this size, or <code>TNULL</code>. In the latter case, a
									block of this size will be allocated and maintained internally, and
									freed when the resulting memory manager is getting destroyed.
									Default: <code>0</code> 
								</li>
								<li>
									<code>TMem_LowFrag, (TBOOL)</code> - This tag is considered when <code>type</code> is
									<code>TMMT_Static</code>. It will cause the resulting memory manager to use an
									allocation strategy that helps reducing the internal fragmentation, at
									the cost of performance. This is also known as the 'best match'
									strategy. The default is the 'first match' strategy.
									Default: <code>TFALSE</code> 
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>, <a href="#exec:TAlloc"><code>exec:TAlloc()</code></a>, <a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a>,
					<a href="#exec:TGetMemManager"><code>exec:TGetMemManager()</code></a>, <a href="#exec:TCreatePool"><code>exec:TCreatePool()</code></a>, <a href="#exec:TGetTaskMemManager"><code>exec:TGetTaskMemManager()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAlloc" id="exec:TAlloc"><code>TAlloc()</code></a></h3>
<pre>
mem = TAlloc(memmanager,         size)
TAPTR        struct TMemManager* TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function allocates a block of memory from a memory manager.
					A pointer to the allocated block of memory is returned, or <code>TNULL</code> 
					if the request cannot be satisfied. A <code>TNULL</code> memory manager is valid
					and directs requests to the system's general purpose allocator.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>mem</code> - Pointer to a block of memory, or <code>TNULL</code> if out of memory
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>memmanager</code> - Pointer to a memory manager, or <code>TNULL</code> 
					</li>
					<li style="list-style-type: none">
						<code>size</code> - Size of the allocation &#091;bytes&#093;
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Never rely on allocations made with this function to be blank, i.e.
						with all bytes set to zero. use <a href="#exec:TAlloc0"><code>exec:TAlloc0()</code></a> to get a blank allocation.
					</li>
					<li>
						Memory for messages must be allocated from a special class of
						memory manager. See <a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a> for details.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TFree"><code>exec:TFree()</code></a>, <a href="#exec:TRealloc"><code>exec:TRealloc()</code></a>, <a href="#exec:TAlloc0"><code>exec:TAlloc0()</code></a>, <a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a>,
					<a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a>, <a href="#exec:TGetSize"><code>exec:TGetSize()</code></a>, <a href="#exec:TGetMemManager"><code>exec:TGetMemManager()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAlloc0" id="exec:TAlloc0"><code>TAlloc0()</code></a></h3>
<pre>
mem = TAlloc0(memmanager,         size)
TAPTR         struct TMemManager* TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Allocate a blank block of memory from a memory manager. This
					function is equivalent to <a href="#TAlloc"><code>TAlloc()</code></a> except for that the returned
					memory is guaranteed to be filled with all bytes set to zero.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>mem</code> - Pointer to a block of memory, or <code>TNULL</code> if memory resource
						exhausted
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>memmanager</code> - Pointer to a memory manager or TNULL
					</li>
					<li style="list-style-type: none">
						<code>size</code> - Size of the allocation &#091;bytes&#093;
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAlloc"><code>exec:TAlloc()</code></a>, <a href="#exec:TFree"><code>exec:TFree()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TQueryInterface" id="exec:TQueryInterface"><code>TQueryInterface()</code></a></h3>
<pre>
interface = TQueryInterface(module,         name,   version, tags)
struct TInterface*          struct TModule* TSTRPTR TUINT16  TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function queries a module for an interface of the given name and
					version. Returns <code>TNULL</code> if no interface could be found or created.
					The resulting interface structure must be freed with a matching
					call to <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a> prior to closing the module from which it was
					obtained.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>interface</code> - Pointer to an interface structure
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>module</code> - Module to obtain the interface from
						</li>
						<li style="list-style-type: none">
							<code>name</code> - Name of the interface
						</li>
						<li style="list-style-type: none">
							<code>version</code> - Minimum version of the interface
						</li>
						<li style="list-style-type: none">
							<code>tags</code> - Additional tags, passed to the module dispatch hook
							in an object of the type <code>struct TInterfaceQuery</code> via the field
							<code>object-&gt;tifq_Tags</code>.
						</li>
					</ul>
				</blockquote>
				<p>
					SEE ALSO:
					<a href="#exec:TOpenModule"><code>exec:TOpenModule()</code></a>, <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TFree" id="exec:TFree"><code>TFree()</code></a></h3>
<pre>
TFree(mem)
      TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Return a block of memory to the memory manager it was
					allocated from.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>mem</code> - Block of memory to be freed. It is safe to pass <code>TNULL</code>.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						This function is responsible for freeing memory that was
						allocated using <a href="#exec:TAlloc"><code>exec:TAlloc()</code></a> or <a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a>. It cannot be used
						for memory that was obtained from a pool or via the standard
						libraries.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAlloc"><code>exec:TAlloc()</code></a>, <a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a>, <a href="#exec:TGetSize"><code>exec:TGetSize()</code></a>, <a href="#exec:TGetMemManager"><code>exec:TGetMemManager()</code></a>,
					<a href="#exec:TRealloc"><code>exec:TRealloc()</code></a>, <a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TRealloc" id="exec:TRealloc"><code>TRealloc()</code></a></h3>
<pre>
newmem = TRealloc(oldmem, newsize)
TAPTR             TAPTR   TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Resize a block of memory that was allocated from a memory
					manager. If <code>newsize</code> is <code>0</code>, the block of memory will be freed
					and the result will be <code>TNULL</code>.
				</p>
				<p>
					This function departs from the usual realloc semantics in that it cannot
					be used to allocate a fresh block of memory. If a <code>TNULL</code> pointer is
					passed as the <code>oldmem</code> argument, this function returns <code>TNULL</code>.
				</p>
				<p>
					If a reallocation fails and the return value is <code>TNULL</code>, the old
					block of memory still belongs to the user.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>newmem</code> - Pointer to memory reallocated to newsize, or <code>TNULL</code> 
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>oldmem</code> - Pointer to memory allocated
					</li>
					<li style="list-style-type: none">
						<code>newsize</code> - New size for the allocation or <code>0</code> 
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Reallocations may require that a given block of memory needs
						to be moved in memory, that is, pointers to this area may become
						invalid.
					</li>
					<li>
						This function is responsible for resizing allocations that were
						allocated using <a href="#exec:TAlloc"><code>exec:TAlloc()</code></a>. It cannot be used for memory that
						was obtained from pools or via the standard libraries.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAlloc"><code>exec:TAlloc()</code></a>, <a href="#exec:TFree"><code>exec:TFree()</code></a>, <a href="#exec:TGetSize"><code>exec:TGetSize()</code></a>, <a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetMemManager" id="exec:TGetMemManager"><code>TGetMemManager()</code></a></h3>
<pre>
memmanager = TGetMemManager(mem)
struct TMemManager*         TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Returns a pointer to the memory manager an allocation was
					made from.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>memmanager</code> - Pointer to a memory manager
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>mem</code> - Pointer to a block of memory
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						<code>TNULL</code> is a valid memory manager, referring to
						the system's general-purpose allocator.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetSize"><code>exec:TGetSize()</code></a>, <a href="#exec:TAlloc"><code>exec:TAlloc()</code></a>, <a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetSize" id="exec:TGetSize"><code>TGetSize()</code></a></h3>
<pre>
size = TGetSize(mem)
TSIZE           TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function gets the size of a block of memory (in bytes) that was
					allocated from a memory manager.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>size</code> - size of the allocation &#091;bytes&#093;
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>mem</code> - Pointer to a block of memory
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetMemManager"><code>exec:TGetMemManager()</code></a>, <a href="#exec:TAlloc"><code>exec:TAlloc()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCreateLock" id="exec:TCreateLock"><code>TCreateLock()</code></a></h3>
<pre>
lock = TCreateLock(tags)
struct TLock*      TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Create a locking object. A lock is a mechanism to protect
					resources from simultaneous accesses from multiple tasks.
					Only one accessor can hold the same lock at a given time.
				</p>
				<p>
					A lock is destroyed with a call to <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>lock</code> - Lock created, or <code>TNULL</code> if creation failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items (none defined yet)
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						The result is undefined if a lock is destroyed in locked state.
						Each call to <a href="#exec:TLock"><code>exec:TLock()</code></a> per calling task must be paired with
						exactly one matching call to <a href="#exec:TUnlock"><code>exec:TUnlock()</code></a>.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TLock"><code>exec:TLock()</code></a>, <a href="#exec:TUnlock"><code>exec:TUnlock()</code></a>, <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TLock" id="exec:TLock"><code>TLock()</code></a></h3>
<pre>
TLock(lock)
      struct TLock*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Gain exclusive access to a lock. If another task is currenty
					holding the lock, the caller will block until the lock is free.
					If no other task holds the lock, then this function returns
					immediately with exclusive access.
				</p>
				<p>
					This function is recursive (or 'nesting'), i.e. it may be called
					subsequently when the lock is already held by the current owner.
					In that case an internal counter is increased and this function
					returns immediately with a lock on the shared resource.
				</p>
				<p>
					Each call per task must be paired with exactly one matching call
					to <a href="#exec:TUnlock"><code>exec:TUnlock()</code></a>, which will decrease the nesting counter. When
					the counter reaches zero, the control is handed over to the next
					waiter or, if there are no waiters, the lock is being released.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>lock</code> - Pointer to a lock created with <a href="#exec:TCreateLock"><code>exec:TCreateLock()</code></a> 
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TUnlock"><code>exec:TUnlock()</code></a>, <a href="#exec:TCreateLock"><code>exec:TCreateLock()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TUnlock" id="exec:TUnlock"><code>TUnlock()</code></a></h3>
<pre>
TUnlock(lock)
        struct TLock*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Release access to a lock which was previously obtained with
					a call to <a href="#exec:TLock"><code>exec:TLock()</code></a>. The next task currently suspended waiting
					for the lock will gain exclusive access to the resource and
					resume.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>lock</code> - Pointer to a locking object in locked state
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TLock"><code>exec:TLock()</code></a>, <a href="#exec:TCreateLock"><code>exec:TCreateLock()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAllocSignal" id="exec:TAllocSignal"><code>TAllocSignal()</code></a></h3>
<pre>
signals = TAllocSignal(prefsignals)
TUINT                  TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Allocate a signal (or a set of preferred signals) from the
					current task. If prefsignals is <code>0</code> then this function will try to
					reserve any single free signal. Otherwise, this function tries to
					reserve the exact set specified.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>signals</code> - Signals allocated. <code>0</code> if out of signals, or if any
						of the signal bits in <code>prefsignals</code> is already in use.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>prefsignals</code> - Preferred set of signals or <code>0</code> for any free signal
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Signals no longer needed should be freed using <a href="#exec:TFreeSignal"><code>exec:TFreeSignal()</code></a>.
					</li>
					<li>
						The Exec module guarantees that there will always be at least 20
						user-allocatable signals per task.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TFreeSignal"><code>exec:TFreeSignal()</code></a>, <a href="#exec:TSignal"><code>exec:TSignal()</code></a>, <a href="#exec:TSetSignal"><code>exec:TSetSignal()</code></a>, <a href="#exec:TWait"><code>exec:TWait()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TFreeSignal" id="exec:TFreeSignal"><code>TFreeSignal()</code></a></h3>
<pre>
TFreeSignal(signals)
            TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Free a single or a set of signals and return them to a task's
					signal pool.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>signals</code> - Signal mask to be freed. It is safe to pass <code>0</code>.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAllocSignal"><code>exec:TAllocSignal()</code></a>, <a href="#exec:TWait"><code>exec:TWait()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TSignal" id="exec:TSignal"><code>TSignal()</code></a></h3>
<pre>
TSignal(task,         signals)
        struct TTask* TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Submit signals to a task. The signal(s) will show up in the
					signalled task. When the task was suspended waiting for any of
					the specified signals, it will resume its operation.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Task to be signalled
					</li>
					<li style="list-style-type: none">
						<code>signals</code> - A set of signals to be submitted
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TSetSignal"><code>exec:TSetSignal()</code></a>, <a href="#exec:TWait"><code>exec:TWait()</code></a>, <a href="#exec:TAllocSignal"><code>exec:TAllocSignal()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TSetSignal" id="exec:TSetSignal"><code>TSetSignal()</code></a></h3>
<pre>
oldsignals = TSetSignal(newsignals, sigmask)
TUINT                   TUINT       TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Set the current task's signal state to the signal bits in
					<code>newsignals</code>, masked through the bits in the <code>sigmask</code> argument,
					and return the old state of the tasks's signals to the caller.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>newsignals</code> - New set of signals
					</li>
					<li style="list-style-type: none">
						<code>sigmask</code> - Signal bits to be affected
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>EXAMPLES</dfn>
<pre>
/* get the current state of all signals, but do not modify them */
signals = TSetSignal(0, 0);

/* clear the TTASK_SIG_ABORT signal */
TSetSignal(0, TTASK_SIG_ABORT);
</pre>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TSignal"><code>exec:TSignal()</code></a>, <a href="#exec:TWait"><code>exec:TWait()</code></a>, <a href="#exec:TAllocSignal"><code>exec:TAllocSignal()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TWait" id="exec:TWait"><code>TWait()</code></a></h3>
<pre>
signals = TWait(sigmask)
TUINT           TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Suspend the current task to wait for one or more of the signals specified
					in <code>sigmask</code> to arrive. Those bits will be cleared from the task's
					signal state and returned to the caller when the function returns. If
					<code>sigmask</code> is <code>0</code>, this function will immediately return <code>0</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>signals</code> - Signals that caused returning
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>sigmask</code> - Set of signals to wait for
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TWaitPort"><code>exec:TWaitPort()</code></a>, <a href="#exec:TSignal"><code>exec:TSignal()</code></a>, <a href="#exec:TSetSignal"><code>exec:TSetSignal()</code></a>, <a href="#exec:TAllocSignal"><code>exec:TAllocSignal()</code></a>,
					<a href="#exec:TWaitTime"><code>exec:TWaitTime()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCreatePort" id="exec:TCreatePort"><code>TCreatePort()</code></a></h3>
<pre>
port = TCreatePort(tags)
struct TMsgPort*   TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Create a message port owned by the current task.
				</p>
				<p>
					A message port is an access point for messages between tasks. It
					can be synchronized on using <a href="#exec:TWaitPort"><code>exec:TWaitPort()</code></a>. Use <a href="#exec:TGetPortSignal"><code>exec:TGetPortSignal()</code></a> 
					to retrieve a port's underlying signal. Using this signal, one or more
					message ports can be synchronized on using <a href="#exec:TWait"><code>exec:TWait()</code></a>.
				</p>
				<p>
					A message port is destroyed with a call to <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>port</code> - Message port created, or <code>TNULL</code> if failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items (none defined yet)
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Every task has an inbuilt <em>user message port</em> already, which can
						be retrieved using <a href="#exec:TGetUserPort"><code>exec:TGetUserPort()</code></a>. Use <a href="#exec:TCreatePort"><code>exec:TCreatePort()</code></a> to create
						more ports if necessary.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TWaitPort"><code>exec:TWaitPort()</code></a>, <a href="#exec:TWait"><code>exec:TWait()</code></a>, <a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a>, <a href="#exec:TGetMsg"><code>exec:TGetMsg()</code></a>,
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>, <a href="#exec:TGetPortSignal"><code>exec:TGetPortSignal()</code></a>, <a href="#exec:TGetUserPort"><code>exec:TGetUserPort()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TPutMsg" id="exec:TPutMsg"><code>TPutMsg()</code></a></h3>
<pre>
TPutMsg(msgport,         replyport,       msg)
        struct TMsgPort* struct TMsgPort* TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Put a message to a message port. If a <code>replyport</code> is specified, the
					message will be sent two-way, and there will be a reply expected at
					this port. If <code>replyport</code> is TNULL, the message will be sent
					one-way and does not return to the sender.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>msgport</code> - Addressed message port
					</li>
					<li style="list-style-type: none">
						<code>replyport</code> - Message port for the reply or <code>TNULL</code> 
					</li>
					<li style="list-style-type: none">
						<code>msg</code> - Message to be sent
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetMsg"><code>exec:TGetMsg()</code></a>, <a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a>, <a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a>, <a href="#exec:TDropMsg"><code>exec:TDropMsg()</code></a>,
					<a href="#exec:TSendMsg"><code>exec:TSendMsg()</code></a>, <a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetMsg" id="exec:TGetMsg"><code>TGetMsg()</code></a></h3>
<pre>
msg = TGetMsg(msgport)
TAPTR         struct TMsgPort*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Unlink the next pending message from a port's message queue and
					return it to the caller. This function does not block; if the
					message queue is empty, this function returns immediately with <code>TNULL</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>msg</code> - Next pending message or <code>TNULL</code> if the queue was empty
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>msgport</code> - Message port to get next message from
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a>, <a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a>, <a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a>, <a href="#exec:TDropMsg"><code>exec:TDropMsg()</code></a>,
					<a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAckMsg" id="exec:TAckMsg"><code>TAckMsg()</code></a></h3>
<pre>
TAckMsg(msg)
        TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Acknowledge a two-way message to its sender, i.e. return it to the
					replyport that was specified by the sender when the message was sent.
				</p>
				<p>
					It is safe to apply this function to one-way messages as well; if
					the message was sent without the expectation of a reply or acknowledgement,
					it will silently be freed by returning the memory to its memory manager.
				</p>
				<p>
					When a message is returned with this function, the sender must not
					rely on modifications made inside the message body. If a changed
					message is to be returned, then <a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a> should be used instead.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>msg</code> - Message to be acknowledged or to be freed, transparently
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						The difference between <a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a> and <a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a> is
						meaningless in local address space, but it may become useful in the
						future.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a>, <a href="#exec:TDropMsg"><code>exec:TDropMsg()</code></a>, <a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a>, <a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TReplyMsg" id="exec:TReplyMsg"><code>TReplyMsg()</code></a></h3>
<pre>
TReplyMsg(msg)
          TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Reply a two-way message to its sender, i.e. return it to the
					replyport that was specified by the sender when the message was sent.
				</p>
				<p>
					It is safe to apply this function to one-way messages as well; if
					the message was sent without the expectation of a reply or acknowledgement,
					it will silently be freed by returning the memory to its memory manager.
				</p>
				<p>
					Use this function for transferring a modified message body back to
					its sender. If the message was not modified and it is only required
					to inform the sender that it has been processed, then <a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a> 
					should be used instead.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>msg</code> - Message to be replied (or to be freed, transparently)
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						The difference between <a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a> and <a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a> is
						meaningless in local address space, but it may become useful in the
						future.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a>, <a href="#exec:TDropMsg"><code>exec:TDropMsg()</code></a>, <a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a>, <a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TDropMsg" id="exec:TDropMsg"><code>TDropMsg()</code></a></h3>
<pre>
TDropMsg(msg)
         TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Abandon a two-way message, i.e. return it to its replyport with the
					internal message status set to <code>TMSG_STATUS_FAILED</code>. This function is
					not guaranteed to return any modifications made inside the message
					body, it will only indicate failure.
				</p>
				<p>
					It is safe to apply this function to one-way messages as well; if
					the message was sent without the expectation of a reply or acknowledgement,
					it will silently be freed by returning the memory to its memory manager.
				</p>
				<p>
					In local address space this function is particularly useful for
					indicating failure to the caller of <a href="#exec:TSendMsg"><code>exec:TSendMsg()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>msg</code> - Message to be abandoned (or to be freed, transparently)
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TSendMsg"><code>exec:TSendMsg()</code></a>, <a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a>, <a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a>, <a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a>,
					<a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TSendMsg" id="exec:TSendMsg"><code>TSendMsg()</code></a></h3>
<pre>
status = TSendMsg(port,            msg)
TUINT             struct TMsgPort* TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function sends a message two-way, synchronized, waiting for
					a reply or an acknowledgement before it returns to the caller.
				</p>
				<p>
					The return value will be set to <code>TMSG_STATUS_FAILED</code> if the
					message has been dropped, or, depending on the return method,
					<code>TMSG_STATUS_REPLIED</code> or <code>TMSG_STATUS_ACKD</code> if it returned
					successfully.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>status</code> - delivery status of the message:
						<blockquote>
							<ul>
								<li>
									<code>TMSG_STATUS_FAILED</code> if the message was dropped
								</li>
								<li>
									<code>TMSG_STATUS_REPLIED</code> if replied
								</li>
								<li>
									<code>TMSG_STATUS_ACKD</code> if acknowledged
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>port</code> - Message port to send message to
					</li>
					<li style="list-style-type: none">
						<code>msg</code> - Message to be sent
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Message ports in local address space have no timeout. If the
						message is not being dropped, replied or acknowledged then
						this function blocks eternally.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a>, <a href="#exec:TAckMsg"><code>exec:TAckMsg()</code></a>, <a href="#exec:TReplyMsg"><code>exec:TReplyMsg()</code></a>, <a href="#exec:TDropMsg"><code>exec:TDropMsg()</code></a>,
					<a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a>, <a href="#exec:TGetSyncPort"><code>exec:TGetSyncPort()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TWaitPort" id="exec:TWaitPort"><code>TWaitPort()</code></a></h3>
<pre>
msg = TWaitPort(port)
TAPTR           struct TMsgPort*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Suspend the current task to wait for a message to arrive at the
					given message port. When a message is already present then this
					function returns immediately. A pointer to the next pending
					message is returned to the caller, but it is not removed from
					the queue. Use <a href="#TGetMsg"><code>TGetMsg()</code></a> to unlink the next message from a port.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>msg</code> - Next pending message in the queue
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>port</code> - Message port
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						The port must have been created in the caller's task.
					</li>
					<li>
						Message ports in local address space have no timeout. If no message
						arrives at the specified port, this function will wait and block forever.
					</li>
					<li>
						You can use <a href="#exec:TGetPortSignal"><code>exec:TGetPortSignal()</code></a> to combine the signals from multiple
						message ports and synchronize on them using <a href="#exec:TWait"><code>exec:TWait()</code></a>.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TCreatePort"><code>exec:TCreatePort()</code></a>, <a href="#exec:TWait"><code>exec:TWait()</code></a>, <a href="#exec:TGetPortSignal"><code>exec:TGetPortSignal()</code></a>, <a href="#exec:TGetMsg"><code>exec:TGetMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetPortSignal" id="exec:TGetPortSignal"><code>TGetPortSignal()</code></a></h3>
<pre>
signal = TGetPortSignal(port)
TUINT                   struct TMsgPort*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function retrieves a message port's underlying signal.
					The typical use of that signal is to use <a href="#exec:TWait"><code>exec:TWait()</code></a> to combine
					waiting for messages from multiple ports.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>signal</code> - The signal that shows up in the port's task
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>port</code> - Message port to get signal from
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TCreatePort"><code>exec:TCreatePort()</code></a>, <a href="#exec:TWait"><code>exec:TWait()</code></a>, <a href="#exec:TWaitPort"><code>exec:TWaitPort()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetUserPort" id="exec:TGetUserPort"><code>TGetUserPort()</code></a></h3>
<pre>
userport = TGetUserPort(task)
struct TMsgPort*        struct TTask*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Get a pointer to a task's primary, asynchronous message port,
					which is reserved for the user. If the task argument is <code>TNULL</code>,
					the caller's own task will be queried.
				</p>
				<p>
					Each task is supplied with an user port upon creation. More
					message ports can be created using <a href="#exec:TCreatePort"><code>exec:TCreatePort()</code></a> during a
					task's lifetime.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>userport</code> - Pointer to task's userport
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Task handle, or <code>TNULL</code> 
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						The user port's underlying signal bit is <code>TTASK_SIG_USER</code>.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetSyncPort"><code>exec:TGetSyncPort()</code></a>, <a href="#exec:TCreatePort"><code>exec:TCreatePort()</code></a>, <a href="#exec:TGetPortSignal"><code>exec:TGetPortSignal()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetSyncPort" id="exec:TGetSyncPort"><code>TGetSyncPort()</code></a></h3>
<pre>
syncport = TGetSyncPort(task)
struct TMsgPort*        struct TTask*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Get a pointer to a task's inbuilt syncport. If task is <code>TNULL</code>,
					the caller's own task will be addressed.
				</p>
				<p>
					The syncport is reserved for synchronized message replies. It
					can be employed by the user if its usage remains strictly limited
					to that purpose.
				</p>
				<p>
					For instance, it is not allowed to send messages using <a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a> 
					expecting a reply at a syncport. This would break Exec functions
					that might use the syncport (or the syncport's signal) internally.
					For asynchronous message communication use the task's user port,
					or create a new port using <a href="#exec:TCreatePort"><code>exec:TCreatePort()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>syncport</code> - Pointer to task's syncport
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Task handle, or <code>TNULL</code> 
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetUserPort"><code>exec:TGetUserPort()</code></a>, <a href="#exec:TCreatePort"><code>exec:TCreatePort()</code></a>, <a href="#exec:TGetPortSignal"><code>exec:TGetPortSignal()</code></a>,
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCreateTask" id="exec:TCreateTask"><code>TCreateTask()</code></a></h3>
<pre>
task = TCreateTask(hook,         taglist)
struct TTask*      struct THook* TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Creates a task, launches a new thread of execution and invokes the
					supplied hook with the message <code>TMSG_INITTASK</code> in the newly
					created context. A return value of <code>TFALSE</code> from the hook function
					causes this function to abandon task creation and to return <code>TNULL</code>.
					If the return value is <code>TTRUE</code>, <a href="#TCreateTask"><code>TCreateTask()</code></a> returns the
					newly created task handle to the caller, and invokes the hook again,
					this time with the message <code>TMSG_RUNTASK</code>.
				</p>
				<p>
					The task handle is destroyed with a call to <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>.
					This will synchronize on the task's completion and free its
					resources. TEKlib tasks must always leave gently through their
					function exit, and all task must be synchronized on properly,
					or the TEKlib framework panics at exit.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Task handle, or <code>TNULL</code> if the task could not be
						established
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>hook</code> - Task initialization hook. Note: <a href="#TCreateTask"><code>TCreateTask()</code></a> will
						operate on an internal copy of this structure, to allow the caller
						to place it on the stack and to throw it away after task creation.
					</li>
					<li style="list-style-type: none">
						<code>taglist</code> - Pointer to an array of tag items:
						<blockquote>
							<ul>
								<li>
									<code>TTask_UserData, TAPTR</code> - Pointer to a initial user data
									pointer that will be attached to the newly created task. It can
									be queried from the task handle using <a href="#exec:TGetTaskData"><code>exec:TGetTaskData()</code></a>.
									Default: <code>TNULL</code> 
								</li>
								<li>
									<code>TTask_Name, TSTRPTR</code> - Pointer to the task's name. If a name is
									supplied, the task can be found using <a href="#exec:TFindTask"><code>exec:TFindTask()</code></a>.
									Default: <code>TNULL</code> 
								</li>
								<li>
									<code>TTask_CurrentDir, TAPTR</code> - With this argument, a directory lock
									can be specified that will be duplicated and used as the new task's
									current directory. By default, tasks inherit their current directory
									from their parent. Default: The caller's current directory
								</li>
								<li>
									<code>TTask_InputFH, (TAPTR)</code> 
								</li>
								<li>
									<code>TTask_OutputFH, (TAPTR)</code> 
								</li>
								<li>
									<code>TTask_ErrorFH, (TAPTR)</code> - These tags allow the caller to
									pass file handles to the newly created task for standard input,
									ouput and error, respectively. By default, the I/O handles for
									newly created tasks are unset and opened on demand, that is, by
									the <a href="io">io</a> module in attempts to open the files &quot;stdio:in&quot;,
									&quot;stdio:out&quot; or &quot;stdio:err&quot;, respectively.
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>, <a href="#exec:TFindTask"><code>exec:TFindTask()</code></a>, <a href="#exec:TGetTaskData"><code>exec:TGetTaskData()</code></a>,
					<a href="#exec:TGetUserPort"><code>exec:TGetUserPort()</code></a>, <a href="#exec:TCreateSysTask"><code>exec:TCreateSysTask()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TFindTask" id="exec:TFindTask"><code>TFindTask()</code></a></h3>
<pre>
task = TFindTask(name)
struct TTask*    TSTRPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Find a named task in the system. If name is <code>TNULL</code> then this function
					will return a pointer to the caller's own task.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Pointer to a task handle or <code>TNULL</code> if not found
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>name</code> - Name of a task or <code>TNULL</code> for finding the caller's own task
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TCreateTask"><code>exec:TCreateTask()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetTaskData" id="exec:TGetTaskData"><code>TGetTaskData()</code></a></h3>
<pre>
userdata = TGetTaskData(task)
TAPTR                   struct TTask*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Get a pointer to a task's user data. A user data pointer can be
					supplied upon task creation using the <code>TTask_UserData</code> tag, and be set
					or overwritten using <a href="#exec:TSetTaskData"><code>exec:TSetTaskData()</code></a> during a task's lifetime.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>userdata</code> - Pointer to a task's user data
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Task handle or <code>TNULL</code> to query the caller's own task
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TSetTaskData"><code>exec:TSetTaskData()</code></a>, <a href="#exec:TCreateTask"><code>exec:TCreateTask()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TSetTaskData" id="exec:TSetTaskData"><code>TSetTaskData()</code></a></h3>
<pre>
olddata = TSetTaskData(task, userdata)
TAPTR                  TAPTR TAPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Set a task's user data pointer and return the previous user data
					pointer to the caller.
				</p>
				<p>
					A user data pointer can be supplied upon task creation using the
					<code>TTask_UserData</code> tag and queried with <a href="#exec:TGetTaskData"><code>exec:TGetTaskData()</code></a> during
					a task's lifetime.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>olddata</code> - Pointer to task's previous user data
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Task handle or <code>TNULL</code> to address the caller's own task
					</li>
					<li style="list-style-type: none">
						<code>userdata</code> - New data to associate with the task
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetTaskData"><code>exec:TGetTaskData()</code></a>, <a href="#exec:TCreateTask"><code>exec:TCreateTask()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetTaskMemManager" id="exec:TGetTaskMemManager"><code>TGetTaskMemManager()</code></a></h3>
<pre>
memmanager = TGetTaskMemManager(task)
struct TMemManager*             struct TTask*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Get a pointer to a task's inbuilt memory manager. Allocations
					made from this memory manager are automatically freed when the
					task exits.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>memmanager</code> - Task's memory manager
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>task</code> - Task handle, or <code>TNULL</code> to query the caller's own task
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAlloc"><code>exec:TAlloc()</code></a>, <a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAllocMsg" id="exec:TAllocMsg"><code>TAllocMsg()</code></a></h3>
<pre>
msg = TAllocMsg(size)
TAPTR           TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Allocate memory for a message. Message allocations behave largely
					like regular allocations, but they originate from their own clsss of
					memory manager. Use <a href="#exec:TFree"><code>exec:TFree()</code></a> to return a message to its memory
					manager. <a href="#exec:TGetSize"><code>exec:TGetSize()</code></a> and <a href="#exec:TGetMemManager"><code>exec:TGetMemManager()</code></a> are valid also.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>msg</code> - Pointer to message memory, or <code>TNULL</code> if failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>size</code> - Size of the requested block of memory &#091;bytes&#093;
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Messages cannot be reallocated. The result from attempts
						to do so will always return <code>TNULL</code>.
					</li>
					<li>
						Never rely on allocations made with this function to be
						filled with all bytes set to zero. Use <a href="#exec:TAllocMsg0"><code>exec:TAllocMsg0()</code></a> to get a
						blank message.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAllocMsg0"><code>exec:TAllocMsg0()</code></a>, <a href="#exec:TAlloc"><code>exec:TAlloc()</code></a>, <a href="#exec:TFree"><code>exec:TFree()</code></a>, <a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a>,
					<a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAllocMsg0" id="exec:TAllocMsg0"><code>TAllocMsg0()</code></a></h3>
<pre>
msg = TAllocMsg0(size)
TAPTR            TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Allocate memory for a message, blank. This function is equivalent
					to <a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a>, except for that the message returned is
					guaranteed to be filled with all bytes set to zero.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>mem</code> - Pointer to message memory, or <code>TNULL</code> if failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>size</code> - Size of the requested block of memory &#091;bytes&#093;
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAllocMsg"><code>exec:TAllocMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TLockAtom" id="exec:TLockAtom"><code>TLockAtom()</code></a></h3>
<pre>
atom = TLockAtom(data, mode)
struct TAtom*    TATPR TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Depending on the mode argument, this function creates, obtains or
					destroys a named atom. Atoms are an extension to locks, allowing
					multiple accessors to create, locate and access resources by name.
					Also, atoms allow shared locking and locking attempts.
				</p>
				<p>
					Atoms are recursive. This means the same task holding a lock on an
					atom is allowed to claim it subsequently, and this function
					returns with a nesting lock immediately. All locks per task must be
					paired with exactly one matching unlock operation.
				</p>
				<p>
					Once locked by the caller, a data field can be associcated with an
					atom using <a href="#exec:TSetAtomData"><code>exec:TSetAtomData()</code></a> and retrieved with <a href="#exec:TGetAtomData"><code>exec:TGetAtomData()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>atom</code> - Pointer to an atom in locked state, or <code>TNULL</code> if failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>data</code> - Pointer to an existing atom or to a name
					</li>
					<li style="list-style-type: none">
						<code>mode</code> - Access modes and flags:
						<blockquote>
							<ul>
								<li>
									<code>TATOMF_NAME</code> -
									This flag indicates that the data argument is expected to be a
									pointer to a name. Otherwise it's expected to be a pointer to
									an existing atom.
								</li>
								<li>
									<code>TATOMF_KEEP</code> -
									If data is a pointer to a name and if no atom of that name
									existed, <code>TNULL</code> is returned. Otherwise this function returns
									with a lock on the atom. Atom is returned.
								</li>
								<li>
									<code>TATOMF_CREATE</code> -
									If combined with <code>TATOMF_NAME</code> and if an atom of that name did
									not exist, it is created and returned in locked state. Returns
									<code>TNULL</code> if out of resources.
								</li>
								<li>
									<code>TATOMF_DESTROY</code> -
									If the atom exists then it is locked and destroyed. If the atom
									does not exist or if the mode is combined with <code>TATOMF_TRY</code> and
									the atom is in use elsewhere, <code>TNULL</code> is returned. Otherwise a
									non-<code>TNULL</code> value is returned.
								</li>
								<li>
									<code>TATOMF_TRY</code> -
									If the atom is currently locked exclusively, returns
									immediately with <code>TNULL</code>. If the atom is currently locked
									shared, then attempts to lock it exclusively return immediately
									with <code>TNULL</code>. Also returns <code>TNULL</code> if combined with
									<code>TATOMF_CREATE</code> and <code>TATOMF_NAME</code> and when an atom of that
									name already exists.
								</li>
								<li>
									<code>TATOMF_SHARED</code> -
									Lock in shared mode. Multiple tasks claiming a shared atom at
									the same time can succeed. If an atom is currently held
									exclusively then all shared lockers will block until the
									exclusive lock is released. If an atom is locked in shared
									mode, attempts to lock it exclusively will block until the atom is
									free.
								</li>
							</ul>
						</blockquote>
						By special convention, <code>TATOMF_CREATE|TATOMF_SHARED</code> returns with
						a shared lock only if an atom of that name already existed. If
						an atom of that name did not exist, it is created and returned
						in exclusively locked state; this allows to safely associate an
						initial data packet to an atom that is used in shared mode later.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						If the caller holds an exclusive lock on an atom, it is
						possible to request a subsequent shared lock. The result will be
						another nesting lock on the atom.
					</li>
					<li>
						If the caller holds a shared lock on the atom, it is not
						allowed to request a subsequent exclusive lock. The results will
						be undefined.
					</li>
					<li>
						Not all possible combinations of the mode flags make sense;
						<code>TATOMF_CREATE</code> without <code>TATOMF_NAME</code> will currently return <code>TNULL</code>.
						The combination of <code>TATOMF_CREATE</code> and <code>TATOMF_DESTROY</code> is undefined.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TUnlockAtom"><code>exec:TUnlockAtom()</code></a>, <a href="#exec:TSetAtomData"><code>exec:TSetAtomData()</code></a>, <a href="#exec:TGetAtomData"><code>exec:TGetAtomData()</code></a>,
					<a href="#exec:TCreateLock"><code>exec:TCreateLock()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TUnlockAtom" id="exec:TUnlockAtom"><code>TUnlockAtom()</code></a></h3>
<pre>
TUnlockAtom(atom,         mode)
            struct TAtom* TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Release access to an atom that has been locked with <a href="#exec:TLockAtom"><code>exec:TLockAtom()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>atom</code> - Atom in locked state
					</li>
					<li style="list-style-type: none">
						<code>mode</code> - Unlocking modes:
						<blockquote>
							<ul>
								<li>
									<code>TATOMF_KEEP</code> - Release only
								</li>
								<li>
									<code>TATOMF_DESTROY</code> - Release and destroy the atom
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TLockAtom"><code>exec:TLockAtom()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetAtomData" id="exec:TGetAtomData"><code>TGetAtomData()</code></a></h3>
<pre>
data = TGetAtomData(atom)
TTAG                struct TAtom*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Query an atom's user data tag. The atom should be in
					locked state and currently being owned by the caller.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>data</code> - Atom's user data
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>atom</code> - Atom, as returned by <a href="#exec:TLockAtom"><code>exec:TLockAtom()</code></a> 
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TSetAtomData"><code>exec:TSetAtomData()</code></a>, <a href="#exec:TLockAtom"><code>exec:TLockAtom()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TSetAtomData" id="exec:TSetAtomData"><code>TSetAtomData()</code></a></h3>
<pre>
olddata = TSetAtomData(atom,         data)
TTAG                   struct TAtom* TTAG
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Associate a user data tag with an atom. The atom should be in
					exclusively locked state and currently being owned by the caller.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>olddata</code> - Previous data tag
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>atom</code> - Atom, as returned by <a href="#TLockAtom"><code>TLockAtom()</code></a> 
					</li>
					<li style="list-style-type: none">
						<code>data</code> - User data tag to be associated
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetAtomData"><code>exec:TGetAtomData()</code></a>, <a href="#exec:TLockAtom"><code>exec:TLockAtom()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCreatePool" id="exec:TCreatePool"><code>TCreatePool()</code></a></h3>
<pre>
pool = TCreatePool(tags)
struct TMemPool*   TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Create a memory pool. A pool is an allocator that groups small
					allocations into larger ones. All pending allocations made from
					a pool will be returned to the pool's underlying memory manager
					once the pool is being destroyed with a call to <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>.
					Pools grow and shrink on demand. Two parameters constitute
					their behavior:
				</p>
				<blockquote>
					<ul>
						<li>
							Pudsize is the size of a 'puddle', i.e. a regular chunk of
							memory that will be allocated from an underlying memory manager
							when a request cannot be satisfied from the current set of
							puddles. Many small allocations can fit into a puddle.
						</li>
						<li>
							Thressize is the maximum size of allocations that go into
							regular puddles. Allocations larger than that will go into
							puddles of their own. Thressize must be less or equal pudsize.
						</li>
					</ul>
				</blockquote>
				<p>
					Both pudsize and thressize can be supplied in taglist arguments
					and remain constant during a pool's lifetime. By default, though,
					TEKlib pools try to determine appropriate settings for pudsize
					and thressize during a pool's lifetime and adapt these parameters
					dynamically.
				</p>
				<p>
					Pools can be useful for sections of code that mainly deal with
					many objects of relatively constant sizes. Allocations in a pool
					are more tightly packed and on smaller boundaries than
					general-purpose allocations.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>pool</code> - Pointer to a pooled allocator or <code>TNULL</code> if failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items:
						<blockquote>
							<ul>
								<li>
									<code>TPool_MemManager, (TAPTR)</code> - Pool's underlying memory manager -
									this is where puddles will be allocated from.
								</li>
								<li>
									<code>TPool_PudSize, (TUINT)</code> - Initial size of puddles &#091;bytes&#093;.
									When <code>TPool_AutoAdapt</code> is enabled, this value can change during
									a pool's lifetime. Default: <code>1024</code> 
								</li>
								<li>
									<code>TPool_ThresSize, (TUINT)</code> - Initial threshold size for
									allocations that go into regular puddles &#091;bytes&#093;. This value must
									be less than or equal pudsize. When <code>TPool_AutoAdapt</code> is enabled,
									this value can change during a pool's lifetime. Default: <code>256</code> 
								</li>
								<li>
									<code>TPool_AutoAdapt, (TBOOL)</code> - Use a simple runtime analysis to
									adapt a pool's pudsize and thressize to the requirements during
									its lifetime. Currently thressize tends to 4 times the average
									size of allocations and pudsize tends to 8 times of thressize.
									Default: <code>TTRUE</code> 
								</li>
								<li>
									<code>TMem_LowFrag, (TBOOL)</code> - Use an allocation strategy that may
									help to reduce a pool's internal fragmentation, at the cost of some
									extra performance. This is also known as the 'best match' strategy.
									The default is the 'first match' strategy. default: <code>TFALSE</code> 
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Pools are not inherently safe to use from multiple tasks at the
						same time. If multiple tasks wish to access it simultaneously then
						the pool must be protected with a locking mechanism.
					</li>
					<li>
						A pool itself can serve the underlying allocator for a memory
						manager. See <a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a> for details.
					</li>
					<li>
						One of the possible benefits of pools is that the efficiency of
						<a href="#exec:TReallocPool"><code>exec:TReallocPool()</code></a> is the same on all platforms, while the efficiency
						of <a href="#exec:TRealloc"><code>exec:TRealloc()</code></a> with a <code>TNULL</code> memory manager can significantly
						differ.
					</li>
					<li>
						As a rule of thumb, use a general-purpose allocator when the
						exact requirements, costs and benefits of a special allocator
						cannot be estimated.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAllocPool"><code>exec:TAllocPool()</code></a>, <a href="#exec:TFreePool"><code>exec:TFreePool()</code></a>, <a href="#exec:TReallocPool"><code>exec:TReallocPool()</code></a>,
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>, <a href="#exec:TCreateMemManager"><code>exec:TCreateMemManager()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAllocPool" id="exec:TAllocPool"><code>TAllocPool()</code></a></h3>
<pre>
mem = TAllocPool(pool,            size)
TAPTR            struct TMemPool* TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function allocates a block of memory from a pool. A Pointer
					to the allocated block of memory is returned, or <code>TNULL</code> if the
					request cannot be satisfied.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>mem</code> - Pointer to a block of memory, or <code>TNULL</code> if out of memory
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>pool</code> - Pointer to a pool created with <a href="#exec:TCreatePool"><code>exec:TCreatePool()</code></a> 
					</li>
					<li style="list-style-type: none">
						<code>size</code> - Size of the allocation &#091;bytes&#093;
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TFreePool"><code>exec:TFreePool()</code></a>, <a href="#exec:TReallocPool"><code>exec:TReallocPool()</code></a>, <a href="#exec:TCreatePool"><code>exec:TCreatePool()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TFreePool" id="exec:TFreePool"><code>TFreePool()</code></a></h3>
<pre>
TFreePool(pool,            mem,  size)
          struct TMemPool* TUINT TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Return a block of memory to the pool from which it was allocated.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>pool</code> - Pointer to the pool the allocation was made from
					</li>
					<li style="list-style-type: none">
						<code>mem</code> - Block of memory to be freed
					</li>
					<li style="list-style-type: none">
						<code>size</code> - Size of the allocation
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAllocPool"><code>exec:TAllocPool()</code></a>, <a href="#exec:TReallocPool"><code>exec:TReallocPool()</code></a>, <a href="#exec:TCreatePool"><code>exec:TCreatePool()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TReallocPool" id="exec:TReallocPool"><code>TReallocPool()</code></a></h3>
<pre>
newmem = TReallocPool(pool,            oldmem, oldsize, newsize)
TAPTR                 struct TMemPool* TAPTR   TUINT    TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Resize a block of memory that has been allocated from a pool. If
					<code>newsize</code> is <code>0</code> then the allocation will be freed, and the result
					will be <code>TNULL</code>. If <code>oldmem</code> is <code>TNULL</code> and <code>oldsize</code> is <code>0</code>,
					a new block will be allocated.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>newmem</code> - Pointer to resized block, or <code>TNULL</code> if failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>pool</code> - Pointer to the pool the allocation was made from
					</li>
					<li style="list-style-type: none">
						<code>oldmem</code> - Pointer to memory allocated
					</li>
					<li style="list-style-type: none">
						<code>oldsize</code> - Previous size of the allocation
					</li>
					<li style="list-style-type: none">
						<code>newsize</code> - New size for the allocation
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						Reallocation may require that the given block of memory needs to
						be moved in memory and pointers to this area may become invalid.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAllocPool"><code>exec:TAllocPool()</code></a>, <a href="#exec:TFreePool"><code>exec:TFreePool()</code></a>, <a href="#exec:TCreatePool"><code>exec:TCreatePool()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TPutIO" id="exec:TPutIO"><code>TPutIO()</code></a></h3>
<pre>
TPutIO(ioreq)
       struct TIORequest*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function puts an I/O request to the device or handler
					specified in the <code>ioreq-&gt;io_Device</code> field.
				</p>
				<p>
					<a href="#TPutIO"><code>TPutIO()</code></a> clears the TIOF_QUICK flag from the <code>ioreq-&gt;io_Flags</code> 
					field, indicating that it prefers asynchronous execution, and
					forwards the request through the <code>BeginIO</code>-vector of the device.
				</p>
				<p>
					Whether or not the request will be executed asynchronously remains
					transparent to the caller. After the request has been processed,
					it will return to the replyport specified in <code>ioreq-&gt;io_ReplyPort</code> 
					and cause the replyport's signal to show up in the caller's task.
				</p>
				<p>
					Always use <a href="#exec:TWaitIO"><code>exec:TWaitIO()</code></a> to synchronize on completion of an I/O
					request and its removal from the replyport queue.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>iorequest</code> - I/O request message to be processed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TWaitIO"><code>exec:TWaitIO()</code></a>, <a href="#exec:TDoIO"><code>exec:TDoIO()</code></a>, <a href="#exec:TCheckIO"><code>exec:TCheckIO()</code></a>, <a href="#exec:TAbortIO"><code>exec:TAbortIO()</code></a>,
					<a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TWaitIO" id="exec:TWaitIO"><code>TWaitIO()</code></a></h3>
<pre>
error = TWaitIO(ioreq)
TINT            struct TIORequest*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function waits for an I/O request to complete and unlinks it
					from its <code>ioreq-&gt;io_ReplyPort</code>. If the request has already finished
					or was processed synchronously then <a href="#TWaitIO"><code>TWaitIO()</code></a> drops through
					immediately.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>error</code> - Contents of the iorequest's <code>io_Error</code> field. A return
						value of <code>0</code> indicates success.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>iorequest</code> - I/O request message to be processed.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TPutIO"><code>exec:TPutIO()</code></a>, <a href="#exec:TDoIO"><code>exec:TDoIO()</code></a>, <a href="#exec:TCheckIO"><code>exec:TCheckIO()</code></a>, <a href="#exec:TAbortIO"><code>exec:TAbortIO()</code></a>,
					<a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TDoIO" id="exec:TDoIO"><code>TDoIO()</code></a></h3>
<pre>
error = TDoIO(ioreq)
TINT          struct TIORequest*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function performs an I/O request and waits for completion.
					<a href="#TDoIO"><code>TDoIO()</code></a> indicates that it prefers synchronous execution by
					setting the <code>TIOF_QUICK</code> flag in the <code>ioreq-&gt;io_Flags</code> field
					before the request is forwarded through the <code>BeginIO</code>-vector of the
					device.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>error</code> - Contents of the iorequest's <code>io_Error</code> field. A return
						value of zero indicates success.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>iorequest</code> - I/O request message to be processed.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TPutIO"><code>exec:TPutIO()</code></a>, <a href="#exec:TWaitIO"><code>exec:TWaitIO()</code></a>, <a href="#exec:TCheckIO"><code>exec:TCheckIO()</code></a>, <a href="#exec:TAbortIO"><code>exec:TAbortIO()</code></a>,
					<a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TCheckIO" id="exec:TCheckIO"><code>TCheckIO()</code></a></h3>
<pre>
complete = TCheckIO(ioreq)
TBOOL               struct TIORequest*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function tests if an I/O request has been completed and
					returns its status to the caller.
				</p>
				<p>
					Note that a finished I/O request still needs to be removed
					from the replyport's queue using <a href="#exec:TWaitIO"><code>exec:TWaitIO()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>complete</code> - Boolean
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>iorequest</code> - I/O request message to be processed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TPutIO"><code>exec:TPutIO()</code></a>, <a href="#exec:TWaitIO"><code>exec:TWaitIO()</code></a>, <a href="#exec:TDoIO"><code>exec:TDoIO()</code></a>, <a href="#exec:TAbortIO"><code>exec:TAbortIO()</code></a>,
					<a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAbortIO" id="exec:TAbortIO"><code>TAbortIO()</code></a></h3>
<pre>
error = TAbortIO(ioreq)
TINT              struct TIORequest*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Ask a device to abort an I/O request that has been initiated
					using <a href="#exec:TPutIO"><code>exec:TPutIO()</code></a>. Note that abortion is a service that
					may or may not be granted by the addressed device or handler.
					You must in no way rely on successful abortion, and you still
					have to synchronize on the I/O request properly using <a href="#exec:TWaitIO"><code>exec:TWaitIO()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>error</code> 
						<blockquote>
							<ul>
								<li>
									<code>0</code> if the request for abortion was sent
								</li>
								<li>
									<code>-1</code> if the request is still pending
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>iorequest</code> - I/O request message to be processed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TPutIO"><code>exec:TPutIO()</code></a>, <a href="#exec:TWaitIO"><code>exec:TWaitIO()</code></a>, <a href="#exec:TDoIO"><code>exec:TDoIO()</code></a>, <a href="#exec:TCheckIO"><code>exec:TCheckIO()</code></a>,
					<a href="#exec:TPutMsg"><code>exec:TPutMsg()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TAllocTimeRequest" id="exec:TAllocTimeRequest"><code>TAllocTimeRequest()</code></a></h3>
<pre>
timereq = TAllocTimeRequest(tags)
struct TTimeRequest*        TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function opens the timer device and returns a pointer to a
					time request.
				</p>
				<p>
					Each time request allocated by this function must be freed using
					<a href="#exec:TFreeTimeRequest"><code>exec:TFreeTimeRequest()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>timereq</code> - Pointer to a time request structure, or <code>TNULL</code> if
						the device open or allocation failed
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items (none defined yet)
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						A single time request cannot be used by multiple tasks
						at the same time. If required, allocate one request per task.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TFreeTimeRequest"><code>exec:TFreeTimeRequest()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TFreeTimeRequest" id="exec:TFreeTimeRequest"><code>TFreeTimeRequest()</code></a></h3>
<pre>
TFreeTimeRequest(timereq)
                 struct TTimeRequest*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function frees a time request that was allocated with
					<a href="#exec:TAllocTimeRequest"><code>exec:TAllocTimeRequest()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>timereq</code> - Pointer to a time request
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TAllocTimeRequest"><code>exec:TAllocTimeRequest()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetSystemTime" id="exec:TGetSystemTime"><code>TGetSystemTime()</code></a></h3>
<pre>
TGetSystemTime(timep)
               TTIME*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function queries a (relative) system time and inserts it into
					the time structure being pointed to by <code>timep</code>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>timep</code> - Pointer to a time structure to be filled
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						It is important to note that a <code>TTIME</code> is a relative quantity.
						It might appear as if the fields filled in by this function could
						in some way reflect an absolute time or date, but this would be
						entirely misleading as the base for a <code>TTIME</code> structure can differ
						among different hosts. For getting an absolute date and time use
						the more expensive date functions.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetUniversalDate"><code>exec:TGetUniversalDate()</code></a>, <a href="#exec:TGetLocalDate"><code>exec:TGetLocalDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetUniversalDate" id="exec:TGetUniversalDate"><code>TGetUniversalDate()</code></a></h3>
<pre>
error = TGetUniversalDate(datep)
TINT                      TDATE*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function queries the system's absolute time and date in UTC
					(Universal Time Coordinated) and inserts it into the <code>TDATE</code> being
					pointed to by <code>datep</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>error</code> - Error value, indicating
						<blockquote>
							<ul>
								<li>
									<code>0</code> - for success
								</li>
								<li>
									<code>-1</code> - invalid arguments
								</li>
								<li>
									<code>-2</code> - no date resource available
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>datep</code> - Pointer to a <code>TDATE</code> receiving the date and time
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<ul>
					<li>
						For measuring a relative time it can be sufficient to use a <code>TTIME</code> 
						structure, which is better accessible by applications and requires
						less complex internal calculations. See <a href="#exec:TGetSystemTime"><code>exec:TGetSystemTime()</code></a> and
						<a href="#teklib:TSubTime"><code>teklib:TSubTime()</code></a> for details.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetLocalDate"><code>exec:TGetLocalDate()</code></a>, <a href="#exec:TGetSystemTime"><code>exec:TGetSystemTime()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TGetLocalDate" id="exec:TGetLocalDate"><code>TGetLocalDate()</code></a></h3>
<pre>
error = TGetLocalDate(datep)
TINT                  TDATE*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function queries the system's local time and date and inserts it
					into the <code>TDATE</code> being pointed to by <code>datep</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>error</code> - Error value, indicating
						<blockquote>
							<ul>
								<li>
									<code>0</code> - for success
								</li>
								<li>
									<code>-1</code> - invalid arguments
								</li>
								<li>
									<code>-2</code> - no date resource available
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>datep</code> - Pointer to a <code>TDATE</code> receiving the date and time
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TGetUniversalDate"><code>exec:TGetUniversalDate()</code></a>, <a href="#exec:TGetSystemTime"><code>exec:TGetSystemTime()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TWaitTime" id="exec:TWaitTime"><code>TWaitTime()</code></a></h3>
<pre>
signals = TWaitTime(timeout, sigmask)
TUINT               TTIME*   TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Suspend the current task to wait for a set of signals or for a
					timeout. Any signals causing this function to return will be
					returned to the caller and cleared from the task's signal state.
					If a timeout causes the return then the return value is <code>0</code>. If
					timeout is <code>TNULL</code> then this function is equivalent to <a href="#exec:TWait"><code>exec:TWait()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>timeout</code> - Pointer to a <code>TTIME</code> structure
					</li>
					<li style="list-style-type: none">
						<code>sigmask</code> - Set of signals to wait for
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>signals</code> - Signals that caused returning, or <code>0</code> if a timeout
						occured
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TWaitDate"><code>exec:TWaitDate()</code></a>, <a href="#exec:TAllocTimeRequest"><code>exec:TAllocTimeRequest()</code></a>, <a href="#exec:TGetSystemTime"><code>exec:TGetSystemTime()</code></a>,
					<a href="#exec:TWait"><code>exec:TWait()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TWaitDate" id="exec:TWaitDate"><code>TWaitDate()</code></a></h3>
<pre>
signals = TWaitDate(datep, sigmask)
TUINT               TDATE* TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Suspend the current task to wait for a set of signals or for an
					absolute date. Any signals causing this function to return will be
					returned to the caller and cleared from the task's signal state.
					If an expiring date causes the return then this function returns <code>0</code>.
					If <code>datep</code> is <code>TNULL</code> then this function is equivalent to <a href="#exec:TWait"><code>exec:TWait()</code></a>.
				</p>
				<ul>
					<li style="list-style-type: none">
						<code>absdate</code> - Pointer to a TDATE structure
					</li>
					<li style="list-style-type: none">
						<code>sigmask</code> - Set of signals to wait for
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>signals</code> - Signals that caused returning, or <code>0</code> if a timeout
						occured
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#exec:TWaitTime"><code>exec:TWaitTime()</code></a>, <a href="#exec:TAllocTimeRequest"><code>exec:TAllocTimeRequest()</code></a>, <a href="#exec:TGetSystemDate"><code>exec:TGetSystemDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="exec:TScanModules" id="exec:TScanModules"><code>TScanModules()</code></a></h3>
<pre>
handle = TScanModules(tags)
struct THandle*       TTAGITEM*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function searches for modules that are available to TEKlib's module
					open function and, if successful, returns a handle that can be queried
					using <a href="#teklib:TGetNextEntry"><code>teklib:TGetNextEntry()</code></a>.
					Each invocation of <a href="#teklib:TGetNextEntry"><code>teklib:TGetNextEntry()</code></a> on the resulting handle returns
					a pointer to a taglist, or <code>TNULL</code> when there are no more entries
					available. Possible tags in this taglist, as currently defined, are:
				</p>
				<blockquote>
					<ul>
						<li>
							<code>TExec_ModuleName, (TSTRPTR)</code> - Name of a module that would
							be available to <a href="#exec:TOpenModule"><code>exec:TOpenModule()</code></a>.
						</li>
					</ul>
				</blockquote>
				<p>
					When you are done scanning for modules, the handle should be destroyed
					with <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>handle</code> - A handle that can be passed to <a href="#teklib:TGetNextEntry"><code>teklib:TGetNextEntry()</code></a>,
						or <code>TNULL</code> if scanning failed.
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<ul>
					<li style="list-style-type: none">
						<code>tags</code> - Pointer to an array of tag items:
						<blockquote>
							<ul>
								<li>
									<code>TExec_ModulePrefix (TSTRPTR)</code> - Pointer to a prefix string.
									If specified, only modules whose names begin with this prefix will
									be returned. Default: <code>TNULL</code> 
								</li>
							</ul>
						</blockquote>
					</li>
				</ul>
			</div>
			<div class="definition"><dfn>EXAMPLE</dfn>
				<p>
					Scan the system for TEKlib modules with the prefix <code>&quot;io&quot;</code>:
				</p>
<pre>
TTAGITEM tags&#091;2&#093;;
tags&#091;0&#093;.tti_Tag = TExec_ModulePrefix;
tags&#091;0&#093;.tti_Value = (TTAG) &quot;io&quot;;
tags&#091;1&#093;.tti_Tag = TTAG_DONE;
struct THandle *handle = TScanModules(tags);
if (handle)
{
    TTAGITEM *entry;
    while ((entry = TGetNextEntry(handle)))
        printf(&quot;%s\n&quot;, (TSTRPTR) TGetTag(entry, TExec_ModuleName, TNULL));
}
TDestroy(handle);
</pre>
				<hr />
			</div>
		</div>
		<div class="node"><h2><a name="util" id="util">util </a></h2>
			<div class="definition"><dfn>FUNCTIONS</dfn>
				<ul>
					<li style="list-style-type: none">
						<a href="#util:TBSwap16"><code>util:TBSwap16()</code></a> - Swap bytes in a 16bit integer
					</li>
					<li style="list-style-type: none">
						<a href="#util:TBSwap32"><code>util:TBSwap32()</code></a> - Swap bytes in a 32bit integer
					</li>
					<li style="list-style-type: none">
						<a href="#util:TDateToDMY"><code>util:TDateToDMY()</code></a> - Convert a date to day, month, year
					</li>
					<li style="list-style-type: none">
						<a href="#util:TDMYToYDay"><code>util:TDMYToYDay()</code></a> - Convert a date to a year day
					</li>
					<li style="list-style-type: none">
						<a href="#util:TGetArgC"><code>util:TGetArgC()</code></a> - Get application's argument count
					</li>
					<li style="list-style-type: none">
						<a href="#util:TGetArgs"><code>util:TGetArgs()</code></a> - Return an application's arguments as a single string
					</li>
					<li style="list-style-type: none">
						<a href="#util:TGetArgV"><code>util:TGetArgV()</code></a> - Get application's argument vector
					</li>
					<li style="list-style-type: none">
						<a href="#util:TGetRand"><code>util:TGetRand()</code></a> - Get pseudo random number
					</li>
					<li style="list-style-type: none">
						<a href="#util:TGetWeekDay"><code>util:TGetWeekDay()</code></a> - Get day of week from day, month and year
					</li>
					<li style="list-style-type: none">
						<a href="#util:TGetWeekNumber"><code>util:TGetWeekNumber()</code></a> - Get week of year from day, month and year
					</li>
					<li style="list-style-type: none">
						<a href="#util:THeapSort"><code>util:THeapSort()</code></a> - Sort a field via reference array and comparison hook
					</li>
					<li style="list-style-type: none">
						<a href="#util:THToNL"><code>util:THToNL()</code></a> - Convert 32bit integer from/to network byte order
					</li>
					<li style="list-style-type: none">
						<a href="#util:THToNS"><code>util:THToNS()</code></a> - Convert 16bit integer from/to network byte order
					</li>
					<li style="list-style-type: none">
						<a href="#util:TIsBigEndian"><code>util:TIsBigEndian()</code></a> - Test if host is big endian
					</li>
					<li style="list-style-type: none">
						<a href="#util:TIsLeapYear"><code>util:TIsLeapYear()</code></a> - Check if a year is a leap year
					</li>
					<li style="list-style-type: none">
						<a href="#util:TIsValidDate"><code>util:TIsValidDate()</code></a> - Check if a date is valid
					</li>
					<li style="list-style-type: none">
						<a href="#util:TMYToDay"><code>util:TMYToDay()</code></a> - Convert month, year to days since 1.1.1601
					</li>
					<li style="list-style-type: none">
						<a href="#util:TPackDate"><code>util:TPackDate()</code></a> - Pack a datebox structure to a TEKlib date
					</li>
					<li style="list-style-type: none">
						<a href="#util:TParseArgs"><code>util:TParseArgs()</code></a> - Parse an argument string
					</li>
					<li style="list-style-type: none">
						<a href="#util:TParseArgV"><code>util:TParseArgV()</code></a> - Parse argument vector
					</li>
					<li style="list-style-type: none">
						<a href="#util:TSeekList"><code>util:TSeekList()</code></a> - Seek in a list
					</li>
					<li style="list-style-type: none">
						<a href="#util:TSetRetVal"><code>util:TSetRetVal()</code></a> - Set application's return value
					</li>
					<li style="list-style-type: none">
						<a href="#util:TStrDup"><code>util:TStrDup()</code></a> - Allocate memory for and copy a string
					</li>
					<li style="list-style-type: none">
						<a href="#util:TStrNDup"><code>util:TStrNDup()</code></a> - Allocate memory for and copy a string, length-limited
					</li>
					<li style="list-style-type: none">
						<a href="#util:TUnpackDate"><code>util:TUnpackDate()</code></a> - Unpack a TEKlib date to a datebox structure
					</li>
					<li style="list-style-type: none">
						<a href="#util:TYDayToDM"><code>util:TYDayToDM()</code></a> - Convert year day to day and month
					</li>
				</ul>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TGetArgC" id="util:TGetArgC"><code>TGetArgC()</code></a></h3>
<pre>
argc = TGetArgC()
TINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Return an application's argument count.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>argc</code> - Number of arguments passd to the application
						</li>
					</ul>
				</blockquote>
				<p>
					The result will be <code>0</code> if an argument vector is unsupported
					by the application startup.
				</p>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TGetArgV"><code>util:TGetArgV()</code></a>, <a href="#util:TSetRetVal"><code>util:TSetRetVal()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TGetArgV" id="util:TGetArgV"><code>TGetArgV()</code></a></h3>
<pre>
argv = TGetArgV()
TSTRPTR*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Return an application's array of arguments.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>argv</code> - Pointer to a <code>TNULL</code>-terminated array of string
							pointers
						</li>
					</ul>
				</blockquote>
				<p>
					The argument vector contains the arguments supplied to the application,
					or <code>TNULL</code> if an argument vector is unsupported by the application
					startup.
				</p>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<p>
					If an <code>argv</code> vector is available, then it will always be terminated
					with an additional array element containing <code>TNULL</code>.
				</p>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TGetArgC"><code>util:TGetArgC()</code></a>, <a href="#util:TSetRetVal"><code>util:TSetRetVal()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TSetRetVal" id="util:TSetRetVal"><code>TSetRetVal()</code></a></h3>
<pre>
success = TSetRetVal(value)
TBOOL                TINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Set an application-wide return value. If supported by the
					application's entry point, the value will be returned to the
					hosting environment.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>success</code> - <code>TTRUE</code> if setting the return value succeeded.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>value</code> - Return value to set in the application
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TGetArgC"><code>util:TGetArgC()</code></a>, <a href="#util:TGetArgV"><code>util:TGetArgV()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:THeapSort" id="util:THeapSort"><code>THeapSort()</code></a></h3>
<pre>
success = THeapSort(refarray, length, hook)
TBOOL               TTAG*     TUINT   struct THook*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Using the Heapsort algorithm, sort data of the given length, via
					a reference array and comparison hook. This layout allows you
					to sort any kind of data structure, including arrays of any type,
					and even lists. The reference array will usually contain indices or
					pointers.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>success</code> - Boolean
						</li>
					</ul>
				</blockquote>
				<p>
					Possible reasons for failure are: No comparison function or reference
					array given or less than two entries to sort.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>refarray</code> - Array of references, i.e. indices or pointers
						</li>
						<li style="list-style-type: none">
							<code>length</code> - Number of entries to be sorted
						</li>
						<li style="list-style-type: none">
							<code>hook</code> - Comparison hook
						</li>
					</ul>
				</blockquote>
				<p>
					The comparison hook function must return a value less than zero
					indicating &quot;ref1 less than ref2&quot;, a value greater zero indicating
					&quot;ref1 greater than ref2&quot;, and zero for &quot;ref1 equal to ref2&quot;. It
					expects a pointer to the following data structure as its object:
				</p>
<pre>
struct CmpData { TTAG ref1; TTAG ref2; };
</pre>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<p>
					The Heapsort algorithm is slower than Quicksort, but it has no
					stack impact, and its performance is insensitive to the initial
					array order.
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TSeekList" id="util:TSeekList"><code>TSeekList()</code></a></h3>
<pre>
newnode = TSeekNode(node,         steps)
struct TNode*       struct TNode* TINTPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Seek in a doubly linked list by a given number of steps either
					forward (steps &gt; 0) or backward (steps &lt; 0), and return the
					node reached, or <code>TNULL</code> if seeked past end or before start of
					the list. If steps is zero, node is returned.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>newnode</code> - Node reached, or <code>TNULL</code> 
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>node</code> - Starting node
						</li>
						<li style="list-style-type: none">
							<code>steps</code> - Number of steps to seek
						</li>
					</ul>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TIsBigEndian" id="util:TIsBigEndian"><code>TIsBigEndian()</code></a></h3>
<pre>
isbig = TIsBigEndian()
TBOOL
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Determine the host's endianness. If the host is a big endian
					architecture, a 32bit register containing <code>0x11223344</code> stored in
					memory would yield the byte sequence <code>0x11</code>, <code>0x22</code>, <code>0x33</code>,
					<code>0x44</code>. On such an architecture, this function returns <code>TTRUE</code>. On
					a little endian architecture, the byte sequence would be <code>0x44</code>,
					<code>0x33</code>, <code>0x22</code>, <code>0x11</code>, and this function returned <code>TFALSE</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>isbig</code> - Boolean. <code>TTRUE</code> if the host is big endian.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:THToNL"><code>util:THToNL()</code></a>, <a href="#util:THToNS"><code>util:THToNS()</code></a>, <a href="#util:TBSwap16"><code>util:TBSwap16()</code></a>, <a href="#util:TBSwap32"><code>util:TBSwap32()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TBSwap16" id="util:TBSwap16"><code>TBSwap16()</code></a></h3>
<pre>
TBSwap16(valp)
         TUINT16*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<blockquote>
					<p>
						Reverse the order of the two bytes in memory to which <code>valp</code> 
						points.
					</p>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>valp</code> - Pointer to a 16bit integer to swap
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:THToNL"><code>util:THToNL()</code></a>, <a href="#util:TBSwap32"><code>util:TBSwap32()</code></a>, <a href="#util:TIsBigEndian"><code>util:TIsBigEndian()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TBSwap32" id="util:TBSwap32"><code>TBSwap32()</code></a></h3>
<pre>
TBSwap32(valp)
         TUINT*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<blockquote>
					<p>
						Reverse the order of the four bytes in memory to which <code>valp</code> 
						points.
					</p>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>valp</code> - Pointer to a 32bit integer to swap
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:THToNL"><code>util:THToNL()</code></a>, <a href="#util:TBSwap16"><code>util:TBSwap16()</code></a>, <a href="#util:TIsBigEndian"><code>util:TIsBigEndian()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TStrDup" id="util:TStrDup"><code>TStrDup()</code></a></h3>
<pre>
dup = TStrDup(memmanager,         string)
TSTRPTR       struct TMemManager* TSTRPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Allocate memory for, copy, and return a pointer to a duplicate of
					a string. If string is <code>TNULL</code>, a string will be allocated containing
					only a string's trailing zero-byte.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>dup</code> - A copy of the string, or <code>TNULL</code> if out of memory.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>memmanager</code> - Memory manager to allocate from, or <code>TNULL</code> 
						</li>
						<li style="list-style-type: none">
							<code>string</code> - String to be duplicated
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<p>
						The resulting string must be freed using <a href="#exec:TFree"><code>exec:TFree()</code></a>.
					</p>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TStrNDup"><code>util:TStrNDup()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TStrNDup" id="util:TStrNDup"><code>TStrNDup()</code></a></h3>
<pre>
dup = TStrNDup(memmanager,         string, maxlen)
TSTRPTR        struct TMemManager* TSTRPTR TSIZE
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Allocate memory for, copy, and return a pointer to a duplicate of
					a string. If string is <code>TNULL</code>, a string will be allocated containing
					only a string's trailing zero-byte. The duplicate will be limited to
					a maximum of maxlen characters.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>dup</code> - A copy of the string, or <code>TNULL</code> if out of memory.
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>memmanager</code> - Memory manager to allocate from, or <code>TNULL</code> 
						</li>
						<li style="list-style-type: none">
							<code>string</code> - String to be duplicated
						</li>
						<li style="list-style-type: none">
							<code>maxlen</code> - Maximum number of bytes to duplicate
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>NOTES</dfn>
				<blockquote>
					<p>
						The resulting string must be freed using <a href="#exec:TFree"><code>exec:TFree()</code></a>.
					</p>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TStrDup"><code>util:TStrDup()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TGetRand" id="util:TGetRand"><code>TGetRand()</code></a></h3>
<pre>
num = TGetRand(seed)
TUINT          TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					From a seeding previous random number, generate a pseudo random
					number in the range from 0 to 2147483647 (hexadecimal
					<code>0x7fffffff</code>).
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>num</code> - Pseudo random number
						</li>
					</ul>
				</blockquote>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TParseArgV" id="util:TParseArgV"><code>TParseArgV()</code></a></h3>
<pre>
handle = TParseArgV(template, argv,    args)
struct THandle*     TSTRPTR   TSTRPTR* TTAG*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Parse an array of string pointers into an arguments array,
					according to a format template.
				</p>
				<p>
					The array of string pointers is here referred to as 'argv', because
					a typical use of this function is to parse an application's
					commandline arguments. Note, however, that it can be applied to any
					other <code>TNULL</code>-terminated array of string pointers as well.
				</p>
				<p>
					The template string specifies the expected format. Options in the
					template are separated by commas. Each argument consists of a
					name, an optional alias, and an optional set of qualifiers. Example:
				</p>
<pre>
-s=SOURCE/A/M,-d=DEST/A/K
</pre>
				<p>
					This format would require one or more source arguments and a single
					destination argument. Neither can be omitted. The SOURCE keyword (or
					its alias -s) does not need to appear in the command line. The DEST
					keyword (or its alias -d) must appear in the commandline to be valid.
					This is how the template would be interpreted:
				</p>
				<table>
					<tr>
						<td class="column1">
							SOURCE one two three DEST foo
						</td>
						<td class="column2">
							Valid
						</td>
					</tr>
					<tr>
						<td class="column1">
							DEST foo -s one
						</td>
						<td class="column2">
							Valid
						</td>
					</tr>
					<tr>
						<td class="column1">
							DEST foo
						</td>
						<td class="column2">
							Rejected - source missing
						</td>
					</tr>
					<tr>
						<td class="column1">
							one two three foo
						</td>
						<td class="column2">
							Rejected - keyword missing
						</td>
					</tr>
					<tr>
						<td class="column1">
							one two dest foo
						</td>
						<td class="column2">
							Valid - keywords are not case-sensitive
						</td>
					</tr>
					<tr>
						<td class="column1">
							one two three -d foo four
						</td>
						<td class="column2">
							Valid - &quot;four&quot; would be added to SOURCE
						</td>
					</tr>
				</table>
				<p>
					An option without qualifiers represents a string argument. If
					present, a pointer to the string will be placed into the
					respective entry in the args array. Qualifiers are:
				</p>
				<p>
					<code>/S</code> - Switch. This is considered a boolean variable. When this
					option is present, the value TTRUE will be written into the
					respective entry in the args array.
				</p>
				<p>
					<code>/N</code> - This argument is considered an integer in decimal notation.
					When present, a pointer to a 32bit signed integer will be placed
					into the respective entry in the args array. A pointer to the
					number is inserted (not the number itself) so that the caller can
					determine whether the argument was specified.
				</p>
				<p>
					<code>/K</code> - Keyword. The option will not be accepted unless the keyword
					appears in the argv vector.
				</p>
				<p>
					<code>/A</code> - Required. This argument cannot be omitted. If not present,
					an error is returned.
				</p>
				<p>
					<code>/M</code> - Multiple strings. Any number of strings will be accepted for
					this option. Not more than one /M modifier should appear in a
					template. Any arguments that cannot be assigned to other options
					will be added to this option. The respective entry in the args
					array will be a pointer to a TNULL-terminated array of string
					pointers.
				</p>
				<p>
					If parsing is successful, this function returns a handle. When you
					are finished processing the arguments, this handle must be passed
					to <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a> to free all associated memory.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>template</code> - Format string
						</li>
						<li style="list-style-type: none">
							<code>argv</code> - Array of string pointers to be parsed
						</li>
						<li style="list-style-type: none">
							<code>args</code> - Pointer to an array of tags to be filled with arguments
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>handle</code> - argument handle
						</li>
					</ul>
				</blockquote>
				<p>
					The argument handle will be TNULL if parsing failed. When the application
					has finished processing the arguments, the handle must be passed to
					<a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a> for freeing all associated memory.
				</p>
			</div>
			<div class="definition"><dfn>EXAMPLE</dfn>
<pre>
/* Template string */
TSTRPTR template = &quot;-f=FROM/A,-c=CONTEXT/K,-r=RECURSE/S,-h=?/S&quot;;

/* Initialize args array to defaults */
TTAG args&#091;4&#093; = {TNULL, (TTAG) &quot;linux_gcc&quot;, TFALSE, TFALSE};

/* Get argv vector */
TSTRPTR *argv = TGetArgV();

/* Pass argv + 1 so the program name argv&#091;0&#093; is excluded */
struct THandle *argh = TParseArgV(template, argv + 1, args);

if (argh &amp;&amp; !args&#091;3&#093;)
{
    /* Use the arguments here. Do not destroy the handle yet! */
}
else
{
    /* Either parsing failed or the &quot;help&quot; option was given */
    printusage();
}

/* Clean up */
TDestroy(argh);
</pre>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:THToNL" id="util:THToNL"><code>THToNL()</code></a></h3>
<pre>
val = THToNL(val)
TUINT         TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					If the software is running on a little-endian architecture, this function
					will byte-swap the value. On a big-endian architecture, it will be
					returned unmodified. This will convert the specified value from/to
					network byte order on any architecture.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>val</code> - 32bit integer, byte-swapped if running on little-endian
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>val</code> - 32bit integer
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:THToNS"><code>util:THToNS()</code></a>, <a href="#util:TIsBigEndian"><code>util:TIsBigEndian()</code></a>, <a href="#util:TBSwap32"><code>util:TBSwap32()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:THToNS" id="util:THToNS"><code>THToNS()</code></a></h3>
<pre>
val = THToNS(val)
TUINT16      TUINT16
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					If the software is running on a little-endian architecture, this function
					will byte-swap the value. On a big-endian architecture, it will be
					returned unmodified. This will convert the specified value from/to
					network byte order on any architecture.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>val</code> - 16bit integer, byte-swapped if running on little-endian
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>val</code> - 16bit integer
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:THToNL"><code>util:THToNL()</code></a>, <a href="#util:TIsBigEndian"><code>util:TIsBigEndian()</code></a>, <a href="#util:TBSwap16"><code>util:TBSwap16()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TParseArgs" id="util:TParseArgs"><code>TParseArgs()</code></a></h3>
<pre>
handle = TParseArgs(template, argstring, argarray)
struct THandle*     TSTRPTR   TSTRPTR    TTAG*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Parse an argument string into an arguments array, according to a
					format template.
				</p>
				<p>
					The template string specifies the expected format. Options in the
					template are separated by commas. Each argument consists of a
					name, an optional alias, and an optional set of qualifiers.
				</p>
				<p>
					If parsing is successful, then this function returns a handle. When
					you are finished processing the arguments, this handle must be
					passed to <a href="#teklib:TDestroy"><code>teklib:TDestroy()</code></a> for freeing all associated memory.
				</p>
				<p>
					See <a href="#util:TParseArgV"><code>util:TParseArgV()</code></a> for a detailed description of the expected format.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>handle</code> - Argument handle, or <code>TNULL</code> if parsing failed
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>template</code> - Format string
						</li>
						<li style="list-style-type: none">
							<code>argv</code> - Array of string pointers to be parsed
						</li>
						<li style="list-style-type: none">
							<code>args</code> - Pointer to an array of tags to be filled
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TGetArgs"><code>util:TGetArgs()</code></a>, <a href="#util:TParseArgV"><code>util:TParseArgV()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TGetArgs" id="util:TGetArgs"><code>TGetArgs()</code></a></h3>
<pre>
args = TGetArgs()
TSTRPTR
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Return an application's argument vector (<code>argv</code>) in a single string,
					with the individual items being seperated with spaces.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>args</code> - application arguments
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TGetArgV"><code>util:TGetArgV()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TIsLeapYear" id="util:TIsLeapYear"><code>TIsLeapYear()</code></a></h3>
<pre>
isleapyear = TIsLeapYear(year)
TBOOL                    TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Check if year is a leap year.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>isleapyear</code> - TTRUE if leap year, TFALSE otherweise
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>year</code> - Year to check
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TIsValidDate"><code>util:TIsValidDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TIsValidDate" id="util:TIsValidDate"><code>TIsValidDate()</code></a></h3>
<pre>
valid = TIsValidDate(day,  month, year)
TBOOL                TUINT TUINT  TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Check if the given combination from day, month, year is a
					valid date, e.g. 29, 2, 2003 would be an invalid date, and
					this function would return <code>TFALSE</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>valid</code> - Boolean
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>day, month, year</code> - Date
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TIsLeapYear"><code>util:TIsLeapYear()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TYDayToDM" id="util:TYDayToDM"><code>TYDayToDM()</code></a></h3>
<pre>
success = TYDayToDM(yearday, year, pday,  pmonth)
TBOOL               TUINT    TUINT TUINT* TUINT*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Convert a year and yearday to a month's day and month of the
					given year.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>yearday</code> - Daynumber in the respective year
						</li>
						<li style="list-style-type: none">
							<code>year</code> - The year
						</li>
						<li style="list-style-type: none">
							<code>pday</code> - Pointer to an integer receiving the day (may be <code>TNULL</code>)
						</li>
						<li style="list-style-type: none">
							<code>pmonth</code> - Pointer to an integer receiving the month (may be
							<code>TNULL</code>)
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TDMYToYDay"><code>util:TDMYToYDay()</code></a>, <a href="#util:TMYToDay"><code>util:TMYToDay()</code></a>, <a href="#util:TPackDate"><code>util:TPackDate()</code></a>, <a href="#util:TUnpackDate"><code>util:TUnpackDate()</code></a>,
					<a href="#util:TDateToDMY"><code>util:TDateToDMY()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TDMYToYDay" id="util:TDMYToYDay"><code>TDMYToYDay()</code></a></h3>
<pre>
yday = TDMYToYDay(day,  month, year)
TUINT             TUINT TUINT  TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Convert a date in the format day, month, year to yearday
					of the given year.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>yday</code> - Day of the year
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>day, month, year</code> - Date
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TYDayToDM"><code>util:TYDayToDM()</code></a>, <a href="#util:TMYToDay"><code>util:TMYToDay()</code></a>, <a href="#util:TPackDate"><code>util:TPackDate()</code></a>, <a href="#util:TUnpackDate"><code>util:TUnpackDate()</code></a>,
					<a href="#util:TDateToDMY"><code>util:TDateToDMY()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TMYToDay" id="util:TMYToDay"><code>TMYToDay()</code></a></h3>
<pre>
day = TMYToDay(month, year)
TUINT          TUINT  TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					From the given month and year, calculate the number of days since
					1-Jan-1601.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>day</code> - Day number since 1.1.1601
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>month</code> - Month to convert
						</li>
						<li style="list-style-type: none">
							<code>year</code> - Year to convert
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TYDayToDM"><code>util:TYDayToDM()</code></a>, <a href="#util:DMYToYDay"><code>util:DMYToYDay()</code></a>, <a href="#util:TPackDate"><code>util:TPackDate()</code></a>, <a href="#util:TUnpackDate"><code>util:TUnpackDate()</code></a>,
					<a href="#util:TDateToDMY"><code>util:TDateToDMY()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TDateToDMY" id="util:TDateToDMY"><code>TDateToDMY()</code></a></h3>
<pre>
TDateToDMY(date,  pday,  pmonth, pyear, ptime)
           TDATE* TUINT* TUINT*  TUINT* TTIME*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function converts a date to a day, month, year, and
					the remaining fraction of the day into a time structure.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>date</code> - TEKlib Date
						</li>
						<li style="list-style-type: none">
							<code>pday</code> - Pointer to an integer for day (may be <code>TNULL</code>)
						</li>
						<li style="list-style-type: none">
							<code>pmonth</code> - Pointer to an integer for month (may be <code>TNULL</code>)
						</li>
						<li style="list-style-type: none">
							<code>pyear</code> - Pointer to an integer for year (may be <code>TNULL</code>)
						</li>
						<li style="list-style-type: none">
							<code>ptime</code> - Pointer to a TEKlib time (may be <code>TNULL</code>)
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TYDayToDM"><code>util:TYDayToDM()</code></a>, <a href="#util:TDMYToYDay"><code>util:TDMYToYDay()</code></a>, <a href="#util:TMYToDay"><code>util:TMYToDay()</code></a>, <a href="#util:TPackDate"><code>util:TPackDate()</code></a>,
					<a href="#util:TUnpackDate"><code>util:TUnpackDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TGetWeekDay" id="util:TGetWeekDay"><code>TGetWeekDay()</code></a></h3>
<pre>
wday = TGetWeekDay(day,  month, year)
TUINT              TUINT TUINT  TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function gets the week's day number (0, sunday - 6, saturday)
					from a date given by day, month, year.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>wday</code> - Day of week
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>day</code> - Day
						</li>
						<li style="list-style-type: none">
							<code>month</code> - Month
						</li>
						<li style="list-style-type: none">
							<code>year</code> - Year
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TGetWeekNumber"><code>util:TGetWeekNumber()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TGetWeekNumber" id="util:TGetWeekNumber"><code>TGetWeekNumber()</code></a></h3>
<pre>
wnumber = TGetWeekDay(day,  month, year)
TUINT                 TUINT TUINT  TUINT
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					This function gets the year's week number from a date given by
					day, month, year.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>wnumber</code> - Week of year
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>day</code> - Day
						</li>
						<li style="list-style-type: none">
							<code>month</code> - Month
						</li>
						<li style="list-style-type: none">
							<code>year</code> - Year
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TGetWeekDay"><code>util:TGetWeekDay()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TPackDate" id="util:TPackDate"><code>TPackDate()</code></a></h3>
<pre>
success = TPackDate(datebox,         tdate)
TBOOL               struct TDateBox* TDATE*
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Convert a datebox structure to a date. All fields with a
					corresponding bit in <code>datebox-&gt;tdb_Fields</code> will be possibly
					taken into account. Fields required are <code>TDB_YEAR</code> and either
					<code>TDB_MONTH</code>, <code>TDB_DAY</code> or <code>TDTB_YDAY</code>. More fields like
					<code>TDB_HOUR</code>, <code>TDB_MINUTE</code> etc. will be incorporated to the
					resulting date as well, if they are present. If not enough
					relevant fields are provided then this function returns <code>TFALSE</code>.
				</p>
				<p>
					See <a href="#util:TUnpackDate"><code>util:TUnpackDate()</code></a> for a description of the flags in
					<code>datebox-&gt;tdb_Fields</code>.
				</p>
			</div>
			<div class="definition"><dfn>RESULTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>success</code> - <code>TTRUE</code> if conversion succeeded
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>datebox</code> - Pointer to a source datebox structure
						</li>
						<li style="list-style-type: none">
							<code>tdate</code> - Pointer to a destination <code>TDATE</code> 
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TUnpackDate"><code>util:TUnpackDate()</code></a> 
				</p>
				<hr />
			</div>
		</div>
		<div class="node"><h3><a name="util:TUnpackDate" id="util:TUnpackDate"><code>TUnpackDate()</code></a></h3>
<pre>
TUnpackDate(date,  datebox,         fields)
            TDATE* struct TDateBox* TUINT16
</pre>
			<div class="definition"><dfn>FUNCTION</dfn>
				<p>
					Convert a date to a datebox structure. At least the fields
					marked in the fields argument will be inserted to the
					resulting datebox structure.
				</p>
				<p>
					Specific combinations of date fields may be sufficient for
					a given purpose, like <code>TDB_DAY|TDB_MONTH|TDB_YEAR</code> or
					<code>TDB_YDAY|TDB_YEAR|TDB_SEC</code>. If you want to receive all
					fields, pass <code>TDB_ALL</code> in the fields argument. The fields
					actually being inserted by this function (which can be more
					than requested) will be flagged as correponding bits in
					<code>datebox-&gt;tdb_Fields</code>.
				</p>
			</div>
			<div class="definition"><dfn>INPUTS</dfn>
				<blockquote>
					<ul>
						<li style="list-style-type: none">
							<code>date</code> - pointer to a source date
						</li>
						<li style="list-style-type: none">
							<code>datebox</code> - pointer to a TDateBox structure to be filled in
						</li>
						<li style="list-style-type: none">
							<code>fields</code> - Fields to be inserted into the datebox structure.
							Valid flag fields:
							<table>
								<tr>
									<td class="column1">
										<strong>Flag</strong> 
									</td>
									<td class="column2">
										<strong>Description</strong> 
									</td>
									<td class="column3">
										<strong>corresponds to</strong> 
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_YEAR
									</td>
									<td class="column2">
										year
									</td>
									<td class="column3">
										datebox-&gt;tdb_Year
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_YDAY
									</td>
									<td class="column2">
										day of year
									</td>
									<td class="column3">
										datebox-&gt;tdb_YDay
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_MONTH
									</td>
									<td class="column2">
										month of year
									</td>
									<td class="column3">
										datebox-&gt;tdb_Month
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_WEEK
									</td>
									<td class="column2">
										week of year
									</td>
									<td class="column3">
										datebox-&gt;tdb_Week
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_WDAY
									</td>
									<td class="column2">
										day of week
									</td>
									<td class="column3">
										datebox-&gt;tdb_WDay
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_DAY
									</td>
									<td class="column2">
										day of month
									</td>
									<td class="column3">
										datebox-&gt;tdb_Day
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_HOUR
									</td>
									<td class="column2">
										hour of day
									</td>
									<td class="column3">
										datebox-&gt;tdb_Hour
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_MINUTE
									</td>
									<td class="column2">
										minute of hour
									</td>
									<td class="column3">
										datebox-&gt;tdb_Minute
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_SEC
									</td>
									<td class="column2">
										second of minute
									</td>
									<td class="column3">
										datebox-&gt;tdb_Sec
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_USEC
									</td>
									<td class="column2">
										1/1000000th sec
									</td>
									<td class="column3">
										datebox-&gt;tdb_USec
									</td>
								</tr>
								<tr>
									<td class="column1">
										TDB_ALL
									</td>
									<td class="column2">
										all of the above
									</td>
									<td class="column3">
										all of the above
									</td>
								</tr>
							</table>
						</li>
					</ul>
				</blockquote>
			</div>
			<div class="definition"><dfn>SEE ALSO</dfn>
				<p>
					<a href="#util:TPackDate"><code>util:TPackDate()</code></a> 
				</p>
				<hr />
				<p>
					Document generated on Wed Mar 18 00:57:35 2009
				</p>
			</div>
		</div>
	</body>
</html>
